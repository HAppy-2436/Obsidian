# 递归

## 定义
递归是函数直接或间接调用自身的编程技巧。递归函数必须包含基准情况（终止条件）和递归情况（自我调用）。递归将复杂问题分解为相同类型的子问题，代码简洁优雅，但可能导致栈溢出和性能问题。递归是分治算法、树遍历、动态规划的基础，也是函数式编程的核心思想。

## 核心内容
**递归三要素**：
1. **递归终止条件**（基准情况）：何时停止递归
2. **递归调用**：函数调用自身
3. **问题规模缩小**：每次递归问题变小

**经典示例**：
```c
// 1. 阶乘
int factorial(int n) {
    if (n <= 1) return 1;        // 基准情况
    return n * factorial(n - 1);  // 递归调用
}

// 2. 斐波那契数列
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);
}

// 3. 汉诺塔
void hanoi(int n, char from, char to, char aux) {
    if (n == 1) {
        printf("Move disk 1 from %c to %c\n", from, to);
        return;
    }
    hanoi(n-1, from, aux, to);
    printf("Move disk %d from %c to %c\n", n, from, to);
    hanoi(n-1, aux, to, from);
}

// 4. 二分查找（递归版）
int binarySearch(int arr[], int left, int right, int target) {
    if (left > right) return -1;
    int mid = left + (right - left) / 2;
    if (arr[mid] == target) return mid;
    if (arr[mid] > target)
        return binarySearch(arr, left, mid-1, target);
    return binarySearch(arr, mid+1, right, target);
}
```

**递归vs迭代**：
| 特性 | 递归 | 迭代 |
|------|------|------|
| 代码 | 简洁优雅 | 冗长 |
| 理解 | 符合问题本质 | 需要状态管理 |
| 性能 | 函数调用开销大 | 效率高 |
| 空间 | 栈空间O(n) | O(1) |
| 风险 | 栈溢出 | 不易溢出 |

**尾递归优化**：
```c
// 普通递归
int sum(int n) {
    if (n == 0) return 0;
    return n + sum(n-1);  // 递归后还有+操作
}

// 尾递归（可优化为迭代）
int sum_tail(int n, int acc) {
    if (n == 0) return acc;
    return sum_tail(n-1, acc+n);  // 递归是最后操作
}
```

**递归转迭代**：
```c
// 递归版阶乘
int fact_rec(int n) {
    if (n <= 1) return 1;
    return n * fact_rec(n-1);
}

// 迭代版阶乘
int fact_iter(int n) {
    int result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}
```

**常见问题**：
1. **栈溢出**：递归深度过大
   - 解决：限制深度、尾递归优化、改迭代
   
2. **重复计算**：如fib(n)
   - 解决：记忆化（memoization）、动态规划

3. **效率低**：函数调用开销
   - 解决：迭代、尾递归优化

## 应用场景
树遍历；图的DFS；分治算法（归并排序、快速排序）；回溯算法；动态规划；数学问题（阶乘、组合）。

## 注意事项
- 必须有明确的终止条件
- 每次递归问题规模必须减小
- 注意栈深度限制（防止溢出）
- 考虑尾递归优化或改迭代

## 关联知识
与 [[函数传参]]、[[栈]]、[[分治算法]]、[[动态规划]]、[[树遍历]] 相关。

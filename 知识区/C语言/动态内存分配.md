# 动态内存分配

## 定义
动态内存分配是在程序运行时（而非编译时）在堆（heap）上分配内存的机制。通过malloc、calloc、realloc分配内存，用free释放。动态内存大小灵活、生命周期可控，但需要手动管理，容易产生内存泄漏、悬空[[指针]]等问题。是实现[[链表]]、动态数组、大型数据结构的基础，也是C语言内存管理的核心。

## 核心内容
**四个核心函数**：
```c
#include <stdlib.h>

// 1. malloc：分配指定字节数的内存
void *malloc(size_t size);
int *p = (int*)malloc(10 * sizeof(int));  // 分配10个int

// 2. calloc：分配并初始化为0
void *calloc(size_t num, size_t size);
int *p = (int*)calloc(10, sizeof(int));   // 10个int，全为0

// 3. realloc：调整已分配内存的大小
void *realloc(void *ptr, size_t new_size);
p = (int*)realloc(p, 20 * sizeof(int));   // 扩展为20个

// 4. free：释放内存
void free(void *ptr);
free(p);
p = NULL;  // 防止悬空指针
```

**使用步骤**：
1. 分配内存
2. 检查是否成功（返回NULL表示失败）
3. 使用内存
4. 释放内存
5. 指针置NULL

**完整示例**：
```c
int *arr = (int*)malloc(n * sizeof(int));
if (arr == NULL) {
    // 内存分配失败
    perror("malloc failed");
    return -1;
}
// 使用arr
for (int i = 0; i < n; i++) {
    arr[i] = i;
}
free(arr);
arr = NULL;
```

**malloc vs calloc**：
- malloc：不初始化，速度快，内容未知
- calloc：初始化为0，稍慢，更安全

**realloc注意事项**：
```c
int *new_p = (int*)realloc(p, new_size);
if (new_p == NULL) {
    // realloc失败，原内存仍有效
    free(p);
} else {
    p = new_p;  // 更新指针
}
```

**常见错误**：
1. **内存泄漏**：分配后未释放
```c
void leak() {
    int *p = malloc(100);
    // 忘记free(p);
}  // p出作用域，内存永久丢失
```

2. **悬空指针**：访问已释放的内存
```c
free(p);
*p = 10;  // 错误！p已释放
```

3. **重复释放**：
```c
free(p);
free(p);  // 错误！双重释放
```

4. **野指针**：使用未初始化的指针
```c
int *p;  // 未初始化
*p = 10;  // 错误！
```

## 应用场景
[[链表]]等动态数据结构；运行时确定大小的数组；大型对象；字符串处理；文件缓冲；树、图等复杂结构。

## 注意事项
- 必须检查malloc返回值
- 一定要free释放内存
- free后指针置NULL
- 不要重复free
- realloc可能移动内存位置

## 关联知识
与 [[指针]]、[[链表]]、[[内存布局]]、[[内存泄漏检测]]、[[堆栈区别]] 相关。

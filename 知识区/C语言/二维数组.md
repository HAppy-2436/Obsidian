# 二维数组

## 定义
二维数组是数组的数组，在内存中按行优先（row-major）连续存储。通过arr[i][j]访问元素，本质上是*(*(arr+i)+j)的语法糖。

## 核心内容
**1. 声明与初始化**
```c
// 声明
int arr[3][4]; // 3行4列

// 初始化
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

// 部分初始化
int arr[2][3] = {1, 2, 3, 4}; // 剩余元素为0
```

**2. 内存布局（行优先）**
```c
int arr[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
// 内存：[1][2][3][4][5][6] 连续存储
```

**3. 指针表示**
```c
int arr[3][4];

// arr是指向int[4]的指针
arr      // &arr[0]，指向第一行
arr + 1  // &arr[1]，指向第二行
arr[i][j] 等价于 *(*(arr + i) + j)

// 第i行第j列的地址
&arr[i][j] == arr[i] + j == *(arr + i) + j
```

**4. 作为函数参数**
```c
// 必须指定列数
void func1(int arr[][4], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%d ", arr[i][j]);
        }
    }
}

// 使用指针（高级）
void func2(int (*arr)[4], int rows) {
    // arr是指向int[4]的指针
}

// 一维指针模拟二维
void func3(int *arr, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i * cols + j]);
        }
    }
}
```

**5. 动态分配**
```c
// 方法1：连续内存
int *arr = (int *)malloc(rows * cols * sizeof(int));
arr[i * cols + j] = value; // 访问

// 方法2：指针数组
int **arr = (int **)malloc(rows * sizeof(int *));
for (int i = 0; i < rows; i++) {
    arr[i] = (int *)malloc(cols * sizeof(int));
}
arr[i][j] = value; // 访问
```

**6. 遍历技巧**
```c
int arr[3][4];

// 方法1：传统双重循环
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 4; j++) {
        printf("%d ", arr[i][j]);
    }
}

// 方法2：一维指针遍历
int *p = &arr[0][0];
for (int i = 0; i < 12; i++) {
    printf("%d ", p[i]);
}
```

## 应用场景
- 矩阵运算：加法、乘法、转置
- 图像处理：像素矩阵
- 棋盘游戏：井字棋、五子棋
- 动态规划：dp[i][j]状态表
- 图的邻接矩阵

## 注意事项
- 作为函数参数时必须指定列数（除了第一维）
- sizeof(arr)返回整个数组大小，sizeof(arr[0])返回一行的大小
- 大二维数组尽量用堆分配（避免栈溢出）
- arr、arr[0]、&arr的数值相同，但类型不同
- 不能用arr[i, j]访问（逗号运算符会返回j）

## 关联知识
与 [[数组]]、[[指针]]、[[函数传参]]、[[动态内存分配]] 相关。

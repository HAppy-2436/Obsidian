# 拓扑排序

## 定义
拓扑排序是对有向无环图（DAG）的一种线性排序，使得对于每条有向边 u -> v，u 在 v 之前。常用于任务调度、依赖关系解析等场景。

## 核心内容
**1. Kahn 算法（基于入度，BFS）**
```cpp
vector<int> topoKahn(int n, vector<vector<int>>& adj) {
    vector<int> indeg(n, 0);
    for (int u = 0; u < n; ++u) for (int v : adj[u]) indeg[v]++;

    queue<int> q;
    for (int i = 0; i < n; ++i) if (indeg[i] == 0) q.push(i);

    vector<int> order;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        order.push_back(u);
        for (int v : adj[u]) {
            if (--indeg[v] == 0) q.push(v);
        }
    }

    if ((int)order.size() != n) return {}; // 有环，无法拓扑排序
    return order;
}
```

**2. DFS 后序实现（逆后序）**
```cpp
vector<int> topoDFS(int n, vector<vector<int>>& adj) {
    vector<int> vis(n, 0), order;
    function<bool(int)> dfs = [&](int u) -> bool {
        vis[u] = 1; // visiting
        for (int v : adj[u]) {
            if (vis[v] == 1) return false; // 发现环
            if (vis[v] == 0) {
                if (!dfs(v)) return false;
            }
        }
        vis[u] = 2; // visited
        order.push_back(u);
        return true;
    };

    for (int i = 0; i < n; ++i) if (vis[i] == 0) if (!dfs(i)) return {};
    reverse(order.begin(), order.end());
    return order;
}
```

**3. 应用与变体**
- 任务调度、构建系统（make 依赖）
- 判断有向图是否有环
- 最长/最短路径在 DAG 上（用拓扑序 DP）
- 课程安排（Course Schedule）题型

## 应用场景
- 任务、模块或资源的依赖排序
- 编译/构建系统、数据处理流水线
- DAG 上的动态规划（最长路、计数拓扑路径数）
- 事件调度与优先级解析

## 注意事项
- 拓扑排序仅在 DAG 上有解；存在回路时无解
- 节点编号与输入顺序可能影响合法拓扑序的具体输出
- Kahn 算法可用于检测环并生成任一合法拓扑序
- 当题目要求字典序最小或满足额外约束时，可用优先队列替代队列
- 注意多源（多个入度为0的节点）时的处理策略

## 关联知识
与 [[图论]]、[[最短路算法]]、[[强连通分量]] 相关。

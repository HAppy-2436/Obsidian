# 网络流

## 定义
网络流是图论中研究流量传输的模型，核心问题包括最大流（从源点到汇点的最大流量）和最小割（切断源汇的最小容量）。最大流=最小割定理是网络流的基础。常用 Dinic 算法求解。

## 核心内容
**1. Dinic 算法（最大流）**
```cpp
struct Dinic {
    struct Edge {
        int to, cap, rev; // 目标节点、容量、反向边索引
    };
    
    int n;
    vector<vector<Edge>> graph;
    vector<int> level, iter;
    
    Dinic(int _n): n(_n), graph(n), level(n), iter(n) {}
    
    void add_edge(int from, int to, int cap) {
        graph[from].push_back({to, cap, (int)graph[to].size()});
        graph[to].push_back({from, 0, (int)graph[from].size() - 1});
    }
    
    bool bfs(int s, int t) {
        fill(level.begin(), level.end(), -1);
        queue<int> q;
        level[s] = 0;
        q.push(s);
        
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (auto& e : graph[u]) {
                if (e.cap > 0 && level[e.to] < 0) {
                    level[e.to] = level[u] + 1;
                    q.push(e.to);
                }
            }
        }
        
        return level[t] >= 0;
    }
    
    int dfs(int u, int t, int f) {
        if (u == t) return f;
        
        for (int& i = iter[u]; i < graph[u].size(); ++i) {
            Edge& e = graph[u][i];
            if (e.cap > 0 && level[u] < level[e.to]) {
                int d = dfs(e.to, t, min(f, e.cap));
                if (d > 0) {
                    e.cap -= d;
                    graph[e.to][e.rev].cap += d;
                    return d;
                }
            }
        }
        
        return 0;
    }
    
    long long max_flow(int s, int t) {
        long long flow = 0;
        while (bfs(s, t)) {
            fill(iter.begin(), iter.end(), 0);
            int f;
            while ((f = dfs(s, t, INT_MAX)) > 0) {
                flow += f;
            }
        }
        return flow;
    }
};

// 时间复杂度：O(V^2 * E)
```

**2. 最大流最小割定理**
```cpp
// 最大流 = 最小割
// 最小割：将图分为 S 和 T 两部分（s∈S, t∈T），使得 S 到 T 的边容量和最小
// 求解：先求最大流，然后找残留网络中从 s 可达的点集 S

vector<bool> min_cut(Dinic& dinic, int s) {
    int n = dinic.n;
    vector<bool> reachable(n, false);
    queue<int> q;
    q.push(s);
    reachable[s] = true;
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto& e : dinic.graph[u]) {
            if (e.cap > 0 && !reachable[e.to]) {
                reachable[e.to] = true;
                q.push(e.to);
            }
        }
    }
    
    return reachable; // S 部分
}
```

**3. 最小费用最大流（MCMF）**
```cpp
struct MCMF {
    struct Edge {
        int to, cap, cost, rev;
    };
    
    int n;
    vector<vector<Edge>> graph;
    vector<int> dist, parent, parent_edge;
    const int INF = 1e9;
    
    MCMF(int _n): n(_n), graph(n), dist(n), parent(n), parent_edge(n) {}
    
    void add_edge(int from, int to, int cap, int cost) {
        graph[from].push_back({to, cap, cost, (int)graph[to].size()});
        graph[to].push_back({from, 0, -cost, (int)graph[from].size() - 1});
    }
    
    bool spfa(int s, int t) {
        fill(dist.begin(), dist.end(), INF);
        vector<bool> in_queue(n, false);
        queue<int> q;
        
        dist[s] = 0;
        q.push(s);
        in_queue[s] = true;
        
        while (!q.empty()) {
            int u = q.front(); q.pop();
            in_queue[u] = false;
            
            for (int i = 0; i < graph[u].size(); ++i) {
                Edge& e = graph[u][i];
                if (e.cap > 0 && dist[e.to] > dist[u] + e.cost) {
                    dist[e.to] = dist[u] + e.cost;
                    parent[e.to] = u;
                    parent_edge[e.to] = i;
                    if (!in_queue[e.to]) {
                        q.push(e.to);
                        in_queue[e.to] = true;
                    }
                }
            }
        }
        
        return dist[t] < INF;
    }
    
    pair<long long, long long> min_cost_max_flow(int s, int t) {
        long long flow = 0, cost = 0;
        
        while (spfa(s, t)) {
            int f = INT_MAX;
            for (int u = t; u != s; u = parent[u]) {
                f = min(f, graph[parent[u]][parent_edge[u]].cap);
            }
            
            flow += f;
            cost += (long long)f * dist[t];
            
            for (int u = t; u != s; u = parent[u]) {
                Edge& e = graph[parent[u]][parent_edge[u]];
                e.cap -= f;
                graph[u][e.rev].cap += f;
            }
        }
        
        return {flow, cost};
    }
};

// 时间复杂度：O(V * E * Flow)
```

**4. 二分图最大匹配（转网络流）**
```cpp
// 左部 n 个点，右部 m 个点
// 建图：s -> 左部点（容量1），左部点 -> 右部点（容量1），右部点 -> t（容量1）
int bipartite_matching(int n, int m, vector<pair<int, int>>& edges) {
    int s = 0, t = n + m + 1;
    Dinic dinic(n + m + 2);
    
    for (int i = 1; i <= n; ++i) dinic.add_edge(s, i, 1);
    for (int i = 1; i <= m; ++i) dinic.add_edge(n + i, t, 1);
    
    for (auto [u, v] : edges) {
        dinic.add_edge(u, n + v, 1);
    }
    
    return dinic.max_flow(s, t);
}
```

**5. 多源多汇最大流**
```cpp
// 添加超级源点 s 和超级汇点 t
// s 连接所有源点，所有汇点连接 t
int multi_source_sink_flow(Dinic& dinic, vector<int>& sources, vector<int>& sinks) {
    int n = dinic.n;
    int s = n, t = n + 1;
    
    // 扩展图
    dinic.graph.resize(n + 2);
    dinic.level.resize(n + 2);
    dinic.iter.resize(n + 2);
    dinic.n = n + 2;
    
    for (int src : sources) dinic.add_edge(s, src, INT_MAX);
    for (int snk : sinks) dinic.add_edge(snk, t, INT_MAX);
    
    return dinic.max_flow(s, t);
}
```

**6. 应用：项目选择问题**
```cpp
// 有 n 个项目，每个项目有收益或成本
// 有依赖关系：选择项目 i 必须选择项目 j
// 目标：最大化总收益
// 建图：正收益从 s 连出，负成本连到 t，依赖关系连无穷容量边
// 答案 = 总正收益 - 最小割
```

## 应用场景
- 最大流问题：水管网络、交通流量
- 最小割：网络瓶颈、关键路径
- 二分图匹配：任务分配
- 最小费用流：带权匹配、运输问题
- 项目选择：收益最大化
- 多源多汇流：复杂网络建模

## 注意事项
- 反向边容量初始化为 0
- Dinic 适合稠密图，EK 适合稀疏图
- MCMF 用 SPFA 找增广路（最短路）
- 注意容量和流量的数据类型（long long）
- 最小割需在残留网络中 BFS
- 多源多汇转化为单源单汇
- 费用流可能有负环，需特殊处理

## 关联知识
与 [[图论]]、[[最短路算法]]、[[二分图匹配]]、[[贪心算法]] 相关。

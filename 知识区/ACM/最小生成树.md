# 最小生成树

## 定义
最小生成树（MST）是连接图中所有顶点的边集合，使得总权值最小且无环。主要算法有Kruskal（边排序+并查集）和Prim（点扩展+优先队列），适用于无向连通图。

## 核心内容
**1. Kruskal算法（边排序）**
```cpp
struct Edge {
    int u, v, weight;
    bool operator<(const Edge& other) const {
        return weight < other.weight;
    }
};

class UnionFind {
    vector<int> parent;
public:
    UnionFind(int n) : parent(n) {
        iota(parent.begin(), parent.end(), 0);
    }
    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }
    bool unite(int x, int y) {
        int rootX = find(x), rootY = find(y);
        if (rootX == rootY) return false;
        parent[rootX] = rootY;
        return true;
    }
};

int kruskal(int n, vector<Edge>& edges) {
    sort(edges.begin(), edges.end());  // 按权值排序
    UnionFind uf(n);
    
    int mstWeight = 0;
    int edgeCount = 0;
    
    for (auto& e : edges) {
        if (uf.unite(e.u, e.v)) {  // 不形成环
            mstWeight += e.weight;
            edgeCount++;
            if (edgeCount == n - 1) break;  // 已有n-1条边
        }
    }
    
    return edgeCount == n - 1 ? mstWeight : -1;  // -1表示不连通
}

// 时间复杂度：O(E log E)
```

**2. Prim算法（点扩展）**
```cpp
#include <queue>
#include <vector>
using namespace std;

const int INF = 0x3f3f3f3f;
vector<pair<int, int>> graph[MAXN];  // {to, weight}

int prim(int n) {
    vector<int> dist(n, INF);
    vector<bool> inMST(n, false);
    
    // {距离, 节点}
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    pq.push({0, 0});  // 从节点0开始
    dist[0] = 0;
    
    int mstWeight = 0;
    int edgeCount = 0;
    
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        
        if (inMST[u]) continue;
        inMST[u] = true;
        mstWeight += d;
        edgeCount++;
        
        for (auto [v, w] : graph[u]) {
            if (!inMST[v] && w < dist[v]) {
                dist[v] = w;
                pq.push({w, v});
            }
        }
    }
    
    return edgeCount == n ? mstWeight : -1;
}

// 时间复杂度：O((V+E) log V)
```

**3. Prim算法（朴素版，适合稠密图）**
```cpp
int prim_naive(int n, int graph[MAXN][MAXN]) {
    vector<int> dist(n, INF);
    vector<bool> inMST(n, false);
    
    dist[0] = 0;
    int mstWeight = 0;
    
    for (int i = 0; i < n; i++) {
        // 找最小距离节点
        int u = -1;
        for (int j = 0; j < n; j++) {
            if (!inMST[j] && (u == -1 || dist[j] < dist[u])) {
                u = j;
            }
        }
        
        if (dist[u] == INF) return -1;  // 不连通
        
        inMST[u] = true;
        mstWeight += dist[u];
        
        // 更新距离
        for (int v = 0; v < n; v++) {
            if (!inMST[v] && graph[u][v] < dist[v]) {
                dist[v] = graph[u][v];
            }
        }
    }
    
    return mstWeight;
}

// 时间复杂度：O(V²)
```

**4. 记录MST的边**
```cpp
struct Result {
    int totalWeight;
    vector<Edge> mstEdges;
};

Result kruskal_with_edges(int n, vector<Edge>& edges) {
    sort(edges.begin(), edges.end());
    UnionFind uf(n);
    
    Result result;
    result.totalWeight = 0;
    
    for (auto& e : edges) {
        if (uf.unite(e.u, e.v)) {
            result.totalWeight += e.weight;
            result.mstEdges.push_back(e);
            if (result.mstEdges.size() == n - 1) break;
        }
    }
    
    return result;
}
```

**5. 次小生成树**
```cpp
// 枚举删除MST中的每条边，求剩余边的最小生成树
int secondMST(int n, vector<Edge>& edges, vector<Edge>& mstEdges) {
    int minWeight = INT_MAX;
    
    for (auto& removeEdge : mstEdges) {
        // 临时删除这条边
        int weight = 0;
        UnionFind uf(n);
        int count = 0;
        
        for (auto& e : edges) {
            if (e.u == removeEdge.u && e.v == removeEdge.v && 
                e.weight == removeEdge.weight) continue;
            
            if (uf.unite(e.u, e.v)) {
                weight += e.weight;
                count++;
            }
        }
        
        if (count == n - 1) {
            minWeight = min(minWeight, weight);
        }
    }
    
    return minWeight;
}
```

**6. Kruskal vs Prim对比**
| 算法 | 策略 | 数据结构 | 适用图 | 时间复杂度 |
|------|------|----------|--------|------------|
| Kruskal | 边排序 | 并查集 | 稀疏图 | O(E log E) |
| Prim | 点扩展 | 优先队列 | 稠密图 | O(E log V) |
| Prim朴素 | 点扩展 | 数组 | 稠密图 | O(V²) |

**7. 最小瓶颈生成树**
```cpp
// 最小化最大边权
// 性质：MST就是最小瓶颈生成树
int minBottleneck(int n, vector<Edge>& edges) {
    sort(edges.begin(), edges.end());
    UnionFind uf(n);
    int maxEdge = 0;
    
    for (auto& e : edges) {
        if (uf.unite(e.u, e.v)) {
            maxEdge = max(maxEdge, e.weight);
        }
    }
    
    return maxEdge;
}
```

**8. 应用：连接所有点的最小成本**
```cpp
// LeetCode 1584
int minCostConnectPoints(vector<vector<int>>& points) {
    int n = points.size();
    vector<Edge> edges;
    
    // 完全图，枚举所有边
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int dist = abs(points[i][0] - points[j][0]) + 
                       abs(points[i][1] - points[j][1]);
            edges.push_back({i, j, dist});
        }
    }
    
    return kruskal(n, edges);
}
```

## 应用场景
- 网络设计：最小成本连接所有节点
- 电路设计：PCB布线优化
- 道路规划：最少成本连接城市
- 聚类分析：层次聚类
- 图像分割：分水岭算法
- 近似算法：TSP的近似解

## 注意事项
- 图必须连通（否则无MST）
- MST有n-1条边（n个顶点）
- MST不唯一（权值相同时）
- Kruskal适合稀疏图，Prim适合稠密图
- 使用并查集优化Kruskal
- Prim从任意点开始结果相同
- 边权相同时MST不唯一

## 关联知识
与 [[并查集]]、[[最短路算法]]、[[贪心算法]] 相关。

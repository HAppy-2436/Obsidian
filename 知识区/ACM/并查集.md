# 并查集

## 定义
并查集（Disjoint Set Union, DSU）是维护元素分组的数据结构，支持合并集合（Union）和查询元素所属集合（Find）操作。通过路径压缩和按秩合并优化，时间复杂度接近O(1)。

## 核心内容
**1. 基本实现**
```cpp
class UnionFind {
private:
    vector<int> parent;  // 父节点
    vector<int> rank;    // 树的高度
    int count;           // 集合数量
    
public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        count = n;
        for (int i = 0; i < n; i++) {
            parent[i] = i;  // 初始化：每个元素是独立集合
        }
    }
    
    // 查找根节点（带路径压缩）
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // 路径压缩
        }
        return parent[x];
    }
    
    // 合并集合（按秩合并）
    bool unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return false;  // 已在同一集合
        
        // 按秩合并：小树挂到大树下
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        count--;
        return true;
    }
    
    // 判断是否在同一集合
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
    
    // 集合数量
    int getCount() {
        return count;
    }
};
```

**2. 简化版本（不按秩合并）**
```cpp
int parent[MAXN];

void init(int n) {
    for (int i = 0; i < n; i++) {
        parent[i] = i;
    }
}

int find(int x) {
    return parent[x] == x ? x : parent[x] = find(parent[x]);
}

void unite(int x, int y) {
    parent[find(x)] = find(y);
}

bool connected(int x, int y) {
    return find(x) == find(y);
}
```

**3. 带权并查集**
```cpp
// 维护到根节点的距离
int parent[MAXN], dist[MAXN];

int find(int x) {
    if (parent[x] != x) {
        int root = find(parent[x]);
        dist[x] += dist[parent[x]];  // 更新距离
        parent[x] = root;
    }
    return parent[x];
}

void unite(int x, int y, int d) {
    int rootX = find(x);
    int rootY = find(y);
    parent[rootX] = rootY;
    dist[rootX] = dist[y] + d - dist[x];
}
```

**4. 维护集合大小**
```cpp
class UnionFind {
    vector<int> parent, size;
public:
    UnionFind(int n) : parent(n), size(n, 1) {
        iota(parent.begin(), parent.end(), 0);
    }
    
    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }
    
    void unite(int x, int y) {
        int rootX = find(x), rootY = find(y);
        if (rootX == rootY) return;
        if (size[rootX] < size[rootY]) swap(rootX, rootY);
        parent[rootY] = rootX;
        size[rootX] += size[rootY];
    }
    
    int getSize(int x) {
        return size[find(x)];
    }
};
```

**5. 应用：判断图是否有环**
```cpp
bool hasCycle(int n, vector<pair<int, int>>& edges) {
    UnionFind uf(n);
    for (auto& [u, v] : edges) {
        if (uf.connected(u, v)) {
            return true;  // 加边前已连通，形成环
        }
        uf.unite(u, v);
    }
    return false;
}
```

**6. 应用：朋友圈数量**
```cpp
int findCircleNum(vector<vector<int>>& isConnected) {
    int n = isConnected.size();
    UnionFind uf(n);
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (isConnected[i][j]) {
                uf.unite(i, j);
            }
        }
    }
    return uf.getCount();
}
```

**7. 应用：岛屿数量**
```cpp
int numIslands(vector<vector<char>>& grid) {
    int m = grid.size(), n = grid[0].size();
    UnionFind uf(m * n);
    int count = 0;
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                count++;
                // 向右和向下合并
                if (j + 1 < n && grid[i][j+1] == '1') {
                    if (uf.unite(i*n+j, i*n+j+1)) count--;
                }
                if (i + 1 < m && grid[i+1][j] == '1') {
                    if (uf.unite(i*n+j, (i+1)*n+j)) count--;
                }
            }
        }
    }
    return count;
}
```

**8. 时间复杂度分析**
| 操作 | 无优化 | 路径压缩 | 按秩合并 | 两者结合 |
|------|--------|----------|----------|----------|
| Find | O(n) | O(log n) | O(log n) | O(α(n)) |
| Union | O(n) | O(log n) | O(log n) | O(α(n)) |

*α(n)是反阿克曼函数，增长极慢，实际应用可视为常数*

## 应用场景
- 连通性判断：判断两点是否连通
- 环检测：判断无向图是否有环
- 最小生成树：Kruskal算法
- 动态连通性：在线处理连通性查询
- 朋友圈/社交网络：分组问题
- 岛屿问题：连通块计数

## 注意事项
- 必须使用路径压缩或按秩合并优化（否则退化）
- 初始化时每个元素是独立集合
- find()会修改路径，不是const函数
- 合并时注意合并根节点，不是原节点
- 不支持删除操作（分离集合）
- 适用于无向图，有向图需要特殊处理

## 关联知识
与 [[最小生成树]]、[[拓扑排序]]、[[图的遍历]] 相关。

# 二分查找

## 定义
二分查找是在有序数组中查找目标元素的高效算法，每次将搜索区间减半，时间复杂度O(log n)。关键在于正确处理边界条件和区间定义（左闭右闭或左闭右开）。

## 核心内容
**1. 基本模板（左闭右闭[left, right]）**
```cpp
int binary_search(int arr[], int n, int target) {
    int left = 0, right = n - 1;
    while (left <= right) {  // 注意：<=
        int mid = left + (right - left) / 2;  // 防止溢出
        if (arr[mid] == target) {
            return mid;  // 找到
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;  // 未找到
}
```

**2. 左闭右开模板[left, right)**
```cpp
int binary_search_v2(int arr[], int n, int target) {
    int left = 0, right = n;  // right = n
    while (left < right) {  // 注意：<
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;  // 不是 mid - 1
        }
    }
    return -1;
}
```

**3. 查找第一个等于target的位置**
```cpp
int lower_bound(int arr[], int n, int target) {
    int left = 0, right = n;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;  // 相等也向左收缩
        }
    }
    return left;  // 返回>=target的第一个位置
}
```

**4. 查找最后一个等于target的位置**
```cpp
int upper_bound(int arr[], int n, int target) {
    int left = 0, right = n;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] <= target) {  // 注意：<=
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left - 1;  // 返回<=target的最后一个位置
}
```

**5. STL函数**
```cpp
#include <algorithm>
vector<int> vec = {1, 2, 3, 4, 5};

// lower_bound：第一个>=x的位置
auto it1 = lower_bound(vec.begin(), vec.end(), 3);

// upper_bound：第一个>x的位置
auto it2 = upper_bound(vec.begin(), vec.end(), 3);

// binary_search：是否存在
bool found = binary_search(vec.begin(), vec.end(), 3);

// equal_range：返回[lower, upper)
auto range = equal_range(vec.begin(), vec.end(), 3);
```

**6. 二分答案**
```cpp
// 例：求满足条件的最小值
bool check(int x) {
    // 判断x是否满足条件
}

int binary_answer() {
    int left = MIN_VAL, right = MAX_VAL;
    int ans = -1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            ans = mid;
            right = mid - 1;  // 尝试更小的值
        } else {
            left = mid + 1;
        }
    }
    return ans;
}
```

**7. 实数二分**
```cpp
double binary_search_real(double left, double right) {
    const double EPS = 1e-9;
    while (right - left > EPS) {
        double mid = (left + right) / 2;
        if (check(mid)) {
            right = mid;
        } else {
            left = mid;
        }
    }
    return left;
}
```

## 应用场景
- 有序数组查找：快速定位元素
- 二分答案：最优化问题（最小化最大值、最大化最小值）
- 开方运算：牛顿迭代的替代方案
- 旋转数组：查找旋转点
- 矩阵搜索：二维有序矩阵
- 范围查询：配合lower_bound/upper_bound

## 注意事项
- 数组必须有序
- 注意整数溢出：用`left + (right - left) / 2`
- 区分左闭右闭和左闭右开的边界处理
- while条件：左闭右闭用`<=`，左闭右开用`<`
- 二分答案时注意check函数的单调性
- STL的lower_bound返回迭代器，需判断有效性

## 关联知识
与 [[动态规划]]、[[贪心算法]]、[[前缀和与差分]] 相关。

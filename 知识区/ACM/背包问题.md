# 背包问题

## 定义
背包问题是组合优化问题，在容量限制下选择物品使价值最大化。包括01背包（物品不可分割）、完全背包（无限件）、多重背包（有限件）和分组背包等变种。

## 核心内容
**1. 01背包（经典）**
```cpp
// 每个物品只能选0或1次
int knapsack01(int W, vector<int>& weight, vector<int>& value) {
    int n = weight.size();
    vector<int> dp(W + 1, 0);
    
    for (int i = 0; i < n; i++) {
        // 必须逆序遍历
        for (int w = W; w >= weight[i]; w--) {
            dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);
        }
    }
    
    return dp[W];
}

// 二维DP（更直观）
int knapsack01_2d(int W, vector<int>& weight, vector<int>& value) {
    int n = weight.size();
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            dp[i][w] = dp[i - 1][w];  // 不选
            if (w >= weight[i - 1]) {
                dp[i][w] = max(dp[i][w], 
                              dp[i - 1][w - weight[i - 1]] + value[i - 1]);
            }
        }
    }
    
    return dp[n][W];
}

// 时间复杂度：O(nW)
// 空间复杂度：O(W)（一维）
```

**2. 完全背包**
```cpp
// 每个物品可以选无限次
int unbounded_knapsack(int W, vector<int>& weight, vector<int>& value) {
    int n = weight.size();
    vector<int> dp(W + 1, 0);
    
    for (int i = 0; i < n; i++) {
        // 正序遍历（与01背包区别）
        for (int w = weight[i]; w <= W; w++) {
            dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);
        }
    }
    
    return dp[W];
}

// 二维形式
int unbounded_knapsack_2d(int W, vector<int>& weight, vector<int>& value) {
    int n = weight.size();
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            dp[i][w] = dp[i - 1][w];
            if (w >= weight[i - 1]) {
                // 注意：dp[i][...] 而非 dp[i-1][...]
                dp[i][w] = max(dp[i][w], 
                              dp[i][w - weight[i - 1]] + value[i - 1]);
            }
        }
    }
    
    return dp[n][W];
}
```

**3. 多重背包**
```cpp
// 每个物品有数量限制
int bounded_knapsack(int W, vector<int>& weight, vector<int>& value, vector<int>& count) {
    int n = weight.size();
    vector<int> dp(W + 1, 0);
    
    for (int i = 0; i < n; i++) {
        // 朴素做法：枚举选k个
        for (int w = W; w >= weight[i]; w--) {
            for (int k = 1; k <= count[i] && k * weight[i] <= w; k++) {
                dp[w] = max(dp[w], dp[w - k * weight[i]] + k * value[i]);
            }
        }
    }
    
    return dp[W];
}

// 二进制优化（O(W * Σlog(count[i]))）
int bounded_knapsack_optimized(int W, vector<int>& weight, vector<int>& value, vector<int>& count) {
    vector<int> new_weight, new_value;
    
    // 二进制拆分：count=10 -> 1,2,4,3
    for (int i = 0; i < weight.size(); i++) {
        int c = count[i];
        for (int k = 1; k <= c; k *= 2) {
            new_weight.push_back(k * weight[i]);
            new_value.push_back(k * value[i]);
            c -= k;
        }
        if (c > 0) {
            new_weight.push_back(c * weight[i]);
            new_value.push_back(c * value[i]);
        }
    }
    
    // 转化为01背包
    return knapsack01(W, new_weight, new_value);
}
```

**4. 分组背包**
```cpp
// 每组只能选一个物品
int group_knapsack(int W, vector<vector<int>>& groups_weight, 
                   vector<vector<int>>& groups_value) {
    int n = groups_weight.size();  // 组数
    vector<int> dp(W + 1, 0);
    
    for (int i = 0; i < n; i++) {
        for (int w = W; w >= 0; w--) {
            // 枚举组内物品
            for (int j = 0; j < groups_weight[i].size(); j++) {
                if (w >= groups_weight[i][j]) {
                    dp[w] = max(dp[w], 
                               dp[w - groups_weight[i][j]] + groups_value[i][j]);
                }
            }
        }
    }
    
    return dp[W];
}
```

**5. 恰好装满背包**
```cpp
// 求恰好装满W的最大价值
int exact_knapsack(int W, vector<int>& weight, vector<int>& value) {
    int n = weight.size();
    vector<int> dp(W + 1, INT_MIN);
    dp[0] = 0;  // 容量0时价值为0
    
    for (int i = 0; i < n; i++) {
        for (int w = W; w >= weight[i]; w--) {
            if (dp[w - weight[i]] != INT_MIN) {
                dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);
            }
        }
    }
    
    return dp[W] == INT_MIN ? -1 : dp[W];
}
```

**6. 输出方案**
```cpp
// 记录选择方案
vector<int> knapsack_solution(int W, vector<int>& weight, vector<int>& value) {
    int n = weight.size();
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));
    
    // 填表
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            dp[i][w] = dp[i - 1][w];
            if (w >= weight[i - 1]) {
                dp[i][w] = max(dp[i][w], 
                              dp[i - 1][w - weight[i - 1]] + value[i - 1]);
            }
        }
    }
    
    // 回溯方案
    vector<int> selected;
    int w = W;
    for (int i = n; i >= 1; i--) {
        if (dp[i][w] != dp[i - 1][w]) {
            selected.push_back(i - 1);
            w -= weight[i - 1];
        }
    }
    
    reverse(selected.begin(), selected.end());
    return selected;
}
```

**7. 求方案数**
```cpp
// 恰好装满W的方案数
int count_ways(int W, vector<int>& weight) {
    vector<long long> dp(W + 1, 0);
    dp[0] = 1;
    
    for (int i = 0; i < weight.size(); i++) {
        for (int w = W; w >= weight[i]; w--) {
            dp[w] += dp[w - weight[i]];
        }
    }
    
    return dp[W];
}
```

**8. LeetCode应用**
```cpp
// LeetCode 416：分割等和子集
bool canPartition(vector<int>& nums) {
    int sum = accumulate(nums.begin(), nums.end(), 0);
    if (sum % 2 != 0) return false;
    
    int target = sum / 2;
    vector<bool> dp(target + 1, false);
    dp[0] = true;
    
    for (int num : nums) {
        for (int w = target; w >= num; w--) {
            dp[w] = dp[w] || dp[w - num];
        }
    }
    
    return dp[target];
}

// LeetCode 322：零钱兑换（完全背包求最小）
int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, INT_MAX);
    dp[0] = 0;
    
    for (int coin : coins) {
        for (int w = coin; w <= amount; w++) {
            if (dp[w - coin] != INT_MAX) {
                dp[w] = min(dp[w], dp[w - coin] + 1);
            }
        }
    }
    
    return dp[amount] == INT_MAX ? -1 : dp[amount];
}
```

**9. 背包问题对比表**
| 类型 | 每个物品 | 状态转移 | 遍历顺序 |
|------|---------|---------|---------|
| 01背包 | 最多1个 | dp[i-1][w-weight] | 逆序 |
| 完全背包 | 无限个 | dp[i][w-weight] | 正序 |
| 多重背包 | count[i]个 | 枚举k或二进制优化 | 逆序 |
| 分组背包 | 每组1个 | 枚举组内 | 逆序 |

## 应用场景
- 资源分配：预算分配、项目选择
- 投资组合：股票选择
- 装箱问题：物流优化
- 切割问题：材料利用
- 任务调度：时间资源分配
- 零钱兑换：最少硬币数

## 注意事项
- 01背包必须逆序遍历（防止重复选择）
- 完全背包正序遍历（允许重复选择）
- 恰好装满需要初始化dp[0]=0，其余为-∞
- 多重背包用二进制优化降复杂度
- 空间优化时注意状态依赖
- 输出方案需要二维DP回溯

## 关联知识
与 [[动态规划]]、[[贪心算法]]、[[组合优化]] 相关。

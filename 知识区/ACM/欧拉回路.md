# 欧拉回路

## 定义
欧拉回路是经过图中每条边恰好一次的回路；欧拉路径是经过每条边恰好一次的路径。无向图存在欧拉回路当且仅当所有点度数为偶数且连通；有向图存在欧拉回路当且仅当所有点入度=出度且强连通。

## 核心内容
**1. 欧拉回路判定（无向图）**
```cpp
// 条件：
// 1. 图连通（忽略孤立点）
// 2. 所有点度数为偶数
bool has_euler_circuit_undirected(int n, vector<vector<int>>& adj) {
    // 检查度数
    for (int u = 0; u < n; ++u) {
        if (adj[u].size() % 2 != 0) return false;
    }
    
    // 检查连通性（BFS/DFS）
    vector<bool> vis(n, false);
    function<void(int)> dfs = [&](int u) {
        vis[u] = true;
        for (int v : adj[u]) {
            if (!vis[v]) dfs(v);
        }
    };
    
    int start = -1;
    for (int i = 0; i < n; ++i) {
        if (!adj[i].empty()) {
            start = i;
            break;
        }
    }
    if (start == -1) return true; // 无边
    
    dfs(start);
    for (int i = 0; i < n; ++i) {
        if (!adj[i].empty() && !vis[i]) return false;
    }
    
    return true;
}
```

**2. 欧拉路径判定（无向图）**
```cpp
// 条件：
// 1. 图连通
// 2. 恰好 0 个或 2 个点度数为奇数
bool has_euler_path_undirected(int n, vector<vector<int>>& adj) {
    int odd_count = 0;
    for (int u = 0; u < n; ++u) {
        if (adj[u].size() % 2 != 0) odd_count++;
    }
    
    return odd_count == 0 || odd_count == 2;
}
```

**3. Hierholzer 算法（无向图）**
```cpp
// 求欧拉回路/路径
vector<int> hierholzer_undirected(int n, vector<pair<int, int>>& edges) {
    vector<unordered_multiset<int>> adj(n);
    for (auto [u, v] : edges) {
        adj[u].insert(v);
        adj[v].insert(u);
    }
    
    // 找起点：奇度数点或任意有边的点
    int start = 0;
    for (int i = 0; i < n; ++i) {
        if (adj[i].size() % 2 != 0) {
            start = i;
            break;
        }
        if (!adj[i].empty()) start = i;
    }
    
    vector<int> path;
    stack<int> st;
    st.push(start);
    
    while (!st.empty()) {
        int u = st.top();
        if (adj[u].empty()) {
            path.push_back(u);
            st.pop();
        } else {
            int v = *adj[u].begin();
            adj[u].erase(adj[u].find(v));
            adj[v].erase(adj[v].find(u));
            st.push(v);
        }
    }
    
    reverse(path.begin(), path.end());
    return path;
}

// 时间复杂度：O(E)
```

**4. 欧拉回路判定（有向图）**
```cpp
// 条件：
// 1. 强连通
// 2. 所有点入度 = 出度
bool has_euler_circuit_directed(int n, vector<vector<int>>& adj) {
    vector<int> in_deg(n, 0), out_deg(n, 0);
    
    for (int u = 0; u < n; ++u) {
        out_deg[u] = adj[u].size();
        for (int v : adj[u]) {
            in_deg[v]++;
        }
    }
    
    for (int i = 0; i < n; ++i) {
        if (in_deg[i] != out_deg[i]) return false;
    }
    
    // 检查强连通（简化：忽略）
    return true;
}
```

**5. Hierholzer 算法（有向图）**
```cpp
vector<int> hierholzer_directed(int n, vector<pair<int, int>>& edges) {
    vector<vector<int>> adj(n);
    vector<int> in_deg(n, 0), out_deg(n, 0);
    
    for (auto [u, v] : edges) {
        adj[u].push_back(v);
        out_deg[u]++;
        in_deg[v]++;
    }
    
    // 找起点：出度 > 入度的点或任意有边的点
    int start = 0;
    for (int i = 0; i < n; ++i) {
        if (out_deg[i] > in_deg[i]) {
            start = i;
            break;
        }
        if (!adj[i].empty()) start = i;
    }
    
    vector<int> path;
    stack<int> st;
    st.push(start);
    
    while (!st.empty()) {
        int u = st.top();
        if (adj[u].empty()) {
            path.push_back(u);
            st.pop();
        } else {
            int v = adj[u].back();
            adj[u].pop_back();
            st.push(v);
        }
    }
    
    reverse(path.begin(), path.end());
    return path;
}
```

**6. LeetCode 应用**
```cpp
// LeetCode 753：重新安排行程（有向欧拉路径）
class Solution {
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        unordered_map<string, multiset<string>> graph;
        for (auto& t : tickets) {
            graph[t[0]].insert(t[1]);
        }
        
        vector<string> path;
        stack<string> st;
        st.push("JFK");
        
        while (!st.empty()) {
            string u = st.top();
            if (graph[u].empty()) {
                path.push_back(u);
                st.pop();
            } else {
                string v = *graph[u].begin();
                graph[u].erase(graph[u].begin());
                st.push(v);
            }
        }
        
        reverse(path.begin(), path.end());
        return path;
    }
};
```

**7. 一笔画问题**
```cpp
// 判断图是否可以一笔画
// 欧拉路径：2 个或 0 个奇度数点
// 欧拉回路：0 个奇度数点
bool can_draw_once(int n, vector<vector<int>>& adj) {
    int odd_count = 0;
    for (int u = 0; u < n; ++u) {
        if (adj[u].size() % 2 != 0) odd_count++;
    }
    return odd_count == 0 || odd_count == 2;
}
```

**8. 混合图欧拉回路（稀有）**
```cpp
// 既有有向边又有无向边
// 方法：将无向边定向，使得所有点入度 = 出度
// 转化为网络流问题求解
```

## 应用场景
- 一笔画问题（七桥问题）
- 路径规划（邮递员、巡检路线）
- 电路设计（布线优化）
- DNA 序列重组
- 旅行规划（机票行程）
- 迷宫遍历

## 注意事项
- 无向图：0 或 2 个奇度数点有欧拉路径，0 个有欧拉回路
- 有向图：检查入度=出度，且强连通
- Hierholzer 算法用栈实现，时间 O(E)
- 路径需要反转（因为栈的后进先出）
- 多重边用 multiset 或 vector 维护
- 孤立点不影响欧拉回路判定
- 起点选择：奇度数点或出度>入度的点

## 关联知识
与 [[图的遍历]]、[[DFS]]、[[图论]]、[[强连通分量]] 相关。

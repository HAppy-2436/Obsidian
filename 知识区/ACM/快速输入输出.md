# 快速输入输出

## 定义
快速输入输出是算法竞赛中优化 I/O 性能的技巧，通过关闭同步流、解绑 cin/cout、使用快读模板或 scanf/printf 等方式，将 I/O 时间从秒级降至毫秒级。

## 核心内容
**1. 关闭同步流（最简单优化）**
```cpp
int main() {
    ios::sync_with_stdio(false); // 关闭 C++ 流与 C 流同步
    cin.tie(nullptr);             // 解绑 cin 和 cout
    cout.tie(nullptr);            // 解绑 cout（可选）
    
    int n;
    cin >> n;
    cout << n << '\n'; // 用 '\n' 代替 endl
    return 0;
}

// 注意：关闭同步后不能混用 cin/scanf 或 cout/printf
// 提速：约 2-5 倍
```

**2. 快速读入模板（手写）**
```cpp
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 3) + (x << 1) + (ch ^ 48); // x*10 + (ch-'0')
        ch = getchar();
    }
    return x * f;
}

// 用法
int n = read();
```

**3. 快速输出模板**
```cpp
inline void write(int x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

// 用法
write(123);
putchar('\n');
```

**4. 完整快读快写类**
```cpp
namespace FastIO {
    const int BUF_SIZE = 1 << 20;
    char ibuf[BUF_SIZE], *p1 = ibuf, *p2 = ibuf;
    char obuf[BUF_SIZE], *p3 = obuf;
    
    inline char gc() {
        if (p1 == p2) p2 = (p1 = ibuf) + fread(ibuf, 1, BUF_SIZE, stdin);
        return p1 == p2 ? EOF : *p1++;
    }
    
    inline void pc(char c) {
        if (p3 - obuf == BUF_SIZE) fwrite(obuf, 1, BUF_SIZE, stdout), p3 = obuf;
        *p3++ = c;
    }
    
    inline void flush() { fwrite(obuf, 1, p3 - obuf, stdout); }
    
    inline int read() {
        int x = 0, f = 1; char ch = gc();
        while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = gc(); }
        while (ch >= '0' && ch <= '9') { x = x * 10 + (ch ^ 48); ch = gc(); }
        return x * f;
    }
    
    inline void write(int x) {
        if (x < 0) { pc('-'); x = -x; }
        if (x > 9) write(x / 10);
        pc(x % 10 + '0');
    }
}

using namespace FastIO;

int main() {
    int n = read();
    write(n);
    pc('\n');
    flush(); // 程序结束前必须 flush
    return 0;
}
```

**5. scanf/printf（兼容性好）**
```cpp
// scanf/printf 比 cin/cout 快，但比快读慢
int n;
scanf("%d", &n);
printf("%d\n", n);

// 读取多个数据
int a, b, c;
scanf("%d%d%d", &a, &b, &c);
printf("%d %d %d\n", a, b, c);
```

**6. 读取字符串优化**
```cpp
// 方法1：char数组 + scanf
char s[100005];
scanf("%s", s);

// 方法2：string + 快读
inline void read_string(string& s) {
    s.clear();
    char ch = getchar();
    while (ch == ' ' || ch == '\n') ch = getchar();
    while (ch != ' ' && ch != '\n' && ch != EOF) {
        s += ch;
        ch = getchar();
    }
}
```

**7. 批量输入输出技巧**
```cpp
// 一次性读入所有数据
vector<int> arr(n);
for (int i = 0; i < n; ++i) arr[i] = read();

// 一次性输出（避免频繁调用）
for (int i = 0; i < n; ++i) {
    write(arr[i]);
    pc(i == n - 1 ? '\n' : ' ');
}
```

**8. Python 快速IO（竞赛较少用）**
```python
import sys
input = sys.stdin.readline
print = sys.stdout.write

n = int(input())
print(str(n) + '\n')
```

**9. 性能对比表**
| 方法 | 读入速度 | 写出速度 | 兼容性 |
|------|---------|---------|--------|
| cin/cout | 慢 | 慢 | 高 |
| cin/cout + 优化 | 中 | 中 | 高 |
| scanf/printf | 中 | 中 | 高 |
| 快读快写 | 快 | 快 | 中 |
| fread/fwrite | 最快 | 最快 | 低 |

## 应用场景
- 大数据量输入输出（n > 10^6）
- 时间限制严格的题目
- 多组测试数据
- 字符串密集处理
- 交互题（需要 flush）

## 注意事项
- 关闭同步后不能混用 C/C++ IO
- endl 会刷新缓冲区，用 '\n' 更快
- 快读模板不支持浮点数（需单独实现）
- 交互题必须 flush 或用 endl
- fread/fwrite 需手动处理缓冲区
- Python 用 sys.stdin.readline 加速
- 注意 EOF 判断（读到文件末尾）

## 关联知识
与 [[时间复杂度]]、[[算法优化]]、[[缓冲区]] 相关。

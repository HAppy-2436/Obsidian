# 线段树

## 定义
线段树（Segment Tree）是用于区间查询和修改的树形数据结构，支持O(log n)的单点/区间更新和查询，通过分治思想将区间递归二分，每个节点维护一个区间的统计信息。

## 核心内容
**1. 基础线段树（区间和）**
```cpp
class SegmentTree {
private:
    vector<int> tree, lazy;
    int n;
    
    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }
        
        int mid = (start + end) / 2;
        int left_child = 2 * node + 1;
        int right_child = 2 * node + 2;
        
        build(arr, left_child, start, mid);
        build(arr, right_child, mid + 1, end);
        
        tree[node] = tree[left_child] + tree[right_child];
    }
    
    void update(int node, int start, int end, int idx, int val) {
        if (start == end) {
            tree[node] = val;
            return;
        }
        
        int mid = (start + end) / 2;
        int left_child = 2 * node + 1;
        int right_child = 2 * node + 2;
        
        if (idx <= mid) {
            update(left_child, start, mid, idx, val);
        } else {
            update(right_child, mid + 1, end, idx, val);
        }
        
        tree[node] = tree[left_child] + tree[right_child];
    }
    
    int query(int node, int start, int end, int L, int R) {
        if (R < start || L > end) {
            return 0;  // 区间无交集
        }
        
        if (L <= start && end <= R) {
            return tree[node];  // 区间完全包含
        }
        
        int mid = (start + end) / 2;
        int left_child = 2 * node + 1;
        int right_child = 2 * node + 2;
        
        int left_sum = query(left_child, start, mid, L, R);
        int right_sum = query(right_child, mid + 1, end, L, R);
        
        return left_sum + right_sum;
    }
    
public:
    SegmentTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        lazy.resize(4 * n, 0);
        build(arr, 0, 0, n - 1);
    }
    
    void update(int idx, int val) {
        update(0, 0, n - 1, idx, val);
    }
    
    int query(int L, int R) {
        return query(0, 0, n - 1, L, R);
    }
};

// 时间复杂度：build O(n), update/query O(log n)
// 空间复杂度：O(4n) ≈ O(n)
```

**2. 懒标记（区间修改）**
```cpp
class LazySegmentTree {
private:
    vector<long long> tree, lazy;
    int n;
    
    void push_down(int node, int start, int end) {
        if (lazy[node] != 0) {
            int mid = (start + end) / 2;
            int left_child = 2 * node + 1;
            int right_child = 2 * node + 2;
            
            // 更新子节点
            tree[left_child] += lazy[node] * (mid - start + 1);
            tree[right_child] += lazy[node] * (end - mid);
            
            // 传递懒标记
            lazy[left_child] += lazy[node];
            lazy[right_child] += lazy[node];
            
            lazy[node] = 0;
        }
    }
    
    void update_range(int node, int start, int end, int L, int R, int val) {
        if (R < start || L > end) {
            return;
        }
        
        if (L <= start && end <= R) {
            tree[node] += (long long)val * (end - start + 1);
            lazy[node] += val;
            return;
        }
        
        push_down(node, start, end);
        
        int mid = (start + end) / 2;
        int left_child = 2 * node + 1;
        int right_child = 2 * node + 2;
        
        update_range(left_child, start, mid, L, R, val);
        update_range(right_child, mid + 1, end, L, R, val);
        
        tree[node] = tree[left_child] + tree[right_child];
    }
    
    long long query_range(int node, int start, int end, int L, int R) {
        if (R < start || L > end) {
            return 0;
        }
        
        if (L <= start && end <= R) {
            return tree[node];
        }
        
        push_down(node, start, end);
        
        int mid = (start + end) / 2;
        int left_child = 2 * node + 1;
        int right_child = 2 * node + 2;
        
        return query_range(left_child, start, mid, L, R) +
               query_range(right_child, mid + 1, end, L, R);
    }
    
public:
    LazySegmentTree(int size) {
        n = size;
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
    }
    
    void update(int L, int R, int val) {
        update_range(0, 0, n - 1, L, R, val);
    }
    
    long long query(int L, int R) {
        return query_range(0, 0, n - 1, L, R);
    }
};
```

**3. 区间最大/最小值**
```cpp
// 维护区间最大值
class MaxSegmentTree {
    vector<int> tree;
    int n;
    
    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }
        
        int mid = (start + end) / 2;
        build(arr, 2 * node + 1, start, mid);
        build(arr, 2 * node + 2, mid + 1, end);
        
        tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);
    }
    
    int query_max(int node, int start, int end, int L, int R) {
        if (R < start || L > end) {
            return INT_MIN;
        }
        
        if (L <= start && end <= R) {
            return tree[node];
        }
        
        int mid = (start + end) / 2;
        return max(query_max(2 * node + 1, start, mid, L, R),
                  query_max(2 * node + 2, mid + 1, end, L, R));
    }
    
public:
    MaxSegmentTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 0, 0, n - 1);
    }
    
    int query(int L, int R) {
        return query_max(0, 0, n - 1, L, R);
    }
};
```

**4. 区间GCD**
```cpp
// 维护区间最大公约数
class GCDSegmentTree {
    vector<int> tree;
    int n;
    
    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
    
    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }
        
        int mid = (start + end) / 2;
        build(arr, 2 * node + 1, start, mid);
        build(arr, 2 * node + 2, mid + 1, end);
        
        tree[node] = gcd(tree[2 * node + 1], tree[2 * node + 2]);
    }
    
    int query_gcd(int node, int start, int end, int L, int R) {
        if (R < start || L > end) {
            return 0;
        }
        
        if (L <= start && end <= R) {
            return tree[node];
        }
        
        int mid = (start + end) / 2;
        return gcd(query_gcd(2 * node + 1, start, mid, L, R),
                  query_gcd(2 * node + 2, mid + 1, end, L, R));
    }
    
public:
    GCDSegmentTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 0, 0, n - 1);
    }
    
    int query(int L, int R) {
        return query_gcd(0, 0, n - 1, L, R);
    }
};
```

**5. 动态开点线段树**
```cpp
// 适用于值域很大的情况
struct Node {
    int left, right;  // 子节点索引
    long long sum;
    Node() : left(-1), right(-1), sum(0) {}
};

class DynamicSegmentTree {
    vector<Node> nodes;
    int root;
    long long L, R;  // 值域范围
    
    void update(int& node, long long start, long long end, long long idx, int val) {
        if (node == -1) {
            node = nodes.size();
            nodes.push_back(Node());
        }
        
        if (start == end) {
            nodes[node].sum = val;
            return;
        }
        
        long long mid = start + (end - start) / 2;
        if (idx <= mid) {
            update(nodes[node].left, start, mid, idx, val);
        } else {
            update(nodes[node].right, mid + 1, end, idx, val);
        }
        
        long long left_sum = (nodes[node].left == -1) ? 0 : nodes[nodes[node].left].sum;
        long long right_sum = (nodes[node].right == -1) ? 0 : nodes[nodes[node].right].sum;
        nodes[node].sum = left_sum + right_sum;
    }
    
public:
    DynamicSegmentTree(long long l, long long r) : L(l), R(r), root(-1) {
        nodes.reserve(100000);
    }
    
    void update(long long idx, int val) {
        update(root, L, R, idx, val);
    }
};
```

**6. 应用示例**
```cpp
// LeetCode 307：区域和检索 - 数组可修改
class NumArray {
    SegmentTree* st;
    
public:
    NumArray(vector<int>& nums) {
        st = new SegmentTree(nums);
    }
    
    void update(int index, int val) {
        st->update(index, val);
    }
    
    int sumRange(int left, int right) {
        return st->query(left, right);
    }
};
```

## 应用场景
- 区间查询：RMQ问题（区间最值查询）
- 区间修改：批量更新数据
- 动态数组：支持修改的数组统计
- 扫描线算法：矩形面积并、天际线问题
- 数据库索引：范围查询优化
- 在线算法：实时数据统计

## 注意事项
- 空间需要4n（满二叉树）
- 懒标记需要push_down避免TLE
- 区间边界判断（完全包含、无交集）
- 节点编号：左子2*node+1，右子2*node+2
- 动态开点适用于值域大的情况
- 支持的操作必须满足结合律
- build时间O(n)，不能省略

## 关联知识
与 [[树状数组]]、[[数据结构]]、[[分治算法]]、[[RMQ问题]] 相关。

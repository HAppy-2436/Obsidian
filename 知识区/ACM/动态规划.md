# 动态规划

## 定义
动态规划（DP）通过将问题分解为重叠子问题，利用状态转移方程和最优子结构性质，自底向上或记忆化搜索求解最优化问题，避免重复计算。

## 核心内容
**1. 基本思想**
- **最优子结构**：问题的最优解包含子问题的最优解
- **重叠子问题**：递归过程中多次求解相同子问题
- **状态定义**：dp[i]表示什么
- **状态转移方程**：dp[i]如何从前面的状态推导
- **初始状态**：边界条件
- **计算顺序**：自底向上或记忆化

**2. 斐波那契数列（入门）**
```cpp
// 递归（指数级）
int fib_recursive(int n) {
    if (n <= 1) return n;
    return fib_recursive(n-1) + fib_recursive(n-2);
}

// 记忆化搜索
int memo[MAXN];
int fib_memo(int n) {
    if (n <= 1) return n;
    if (memo[n] != -1) return memo[n];
    return memo[n] = fib_memo(n-1) + fib_memo(n-2);
}

// 动态规划
int fib_dp(int n) {
    int dp[n+1];
    dp[0] = 0; dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}

// 空间优化
int fib_optimized(int n) {
    int a = 0, b = 1;
    for (int i = 2; i <= n; i++) {
        int c = a + b;
        a = b;
        b = c;
    }
    return b;
}
```

**3. 01背包问题**
```cpp
// dp[i][j]：前i个物品，背包容量j的最大价值
int knapsack(int n, int W, int w[], int v[]) {
    int dp[n+1][W+1] = {0};
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= W; j++) {
            if (j >= w[i]) {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);
            } else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[n][W];
}

// 空间优化（一维）
int knapsack_optimized(int n, int W, int w[], int v[]) {
    int dp[W+1] = {0};
    for (int i = 1; i <= n; i++) {
        for (int j = W; j >= w[i]; j--) {  // 逆序
            dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
        }
    }
    return dp[W];
}
```

**4. 最长上升子序列（LIS）**
```cpp
// O(n^2)
int lis(int arr[], int n) {
    int dp[n];
    fill(dp, dp+n, 1);
    int maxLen = 1;
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (arr[j] < arr[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        maxLen = max(maxLen, dp[i]);
    }
    return maxLen;
}

// O(n log n) 贪心+二分
int lis_fast(int arr[], int n) {
    vector<int> tail;
    for (int i = 0; i < n; i++) {
        auto it = lower_bound(tail.begin(), tail.end(), arr[i]);
        if (it == tail.end()) {
            tail.push_back(arr[i]);
        } else {
            *it = arr[i];
        }
    }
    return tail.size();
}
```

**5. 最长公共子序列（LCS）**
```cpp
int lcs(string s1, string s2) {
    int m = s1.length(), n = s2.length();
    int dp[m+1][n+1] = {0};
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m][n];
}
```

**6. 区间DP**
```cpp
// 石子合并问题
int merge_stones(int arr[], int n) {
    int dp[n][n];
    int sum[n+1] = {0};
    
    // 前缀和
    for (int i = 1; i <= n; i++) {
        sum[i] = sum[i-1] + arr[i-1];
    }
    
    // 枚举区间长度
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i + len - 1 < n; i++) {
            int j = i + len - 1;
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; k++) {
                dp[i][j] = min(dp[i][j], 
                    dp[i][k] + dp[k+1][j] + sum[j+1] - sum[i]);
            }
        }
    }
    return dp[0][n-1];
}
```

**7. 状态压缩DP**
```cpp
// 旅行商问题（TSP）
int tsp(int n, int dist[][MAXN]) {
    int dp[1<<n][n];
    memset(dp, 0x3f, sizeof(dp));
    dp[1][0] = 0;  // 从0出发
    
    for (int mask = 1; mask < (1<<n); mask++) {
        for (int u = 0; u < n; u++) {
            if (!(mask & (1<<u))) continue;
            for (int v = 0; v < n; v++) {
                if (mask & (1<<v)) continue;
                dp[mask|(1<<v)][v] = min(dp[mask|(1<<v)][v], 
                    dp[mask][u] + dist[u][v]);
            }
        }
    }
    
    int ans = INT_MAX;
    for (int i = 0; i < n; i++) {
        ans = min(ans, dp[(1<<n)-1][i] + dist[i][0]);
    }
    return ans;
}
```

**8. DP优化技巧**
- **滚动数组**：用两个数组交替使用
- **单调队列优化**：优化区间max/min
- **斜率优化**：凸包优化决策单调性
- **四边形不等式**：优化区间DP
- **矩阵快速幂**：线性递推加速

## 应用场景
- 背包问题：01背包、完全背包、多重背包
- 序列问题：LIS、LCS、编辑距离
- 路径问题：最短路、路径计数
- 区间问题：石子合并、矩阵链乘
- 状态压缩：旅行商、集合DP
- 数位DP：统计特定数字

## 注意事项
- 明确状态定义和转移方程
- 注意初始化和边界条件
- 确定计算顺序（避免使用未计算的状态）
- 空间优化时注意循环顺序
- 区分最优子结构和贪心选择性质
- 调试时打印DP表观察状态转移

## 关联知识
与 [[背包问题]]、[[贪心算法]]、[[二分查找]] 相关。

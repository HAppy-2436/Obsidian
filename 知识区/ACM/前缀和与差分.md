# 前缀和与差分

## 定义
前缀和是数组累加和的预处理技巧，支持O(1)查询区间和；差分是前缀和的逆运算，支持O(1)区间修改。二者互为逆操作，是区间操作优化的核心工具。

## 核心内容
**1. 一维前缀和**
```cpp
// 构建前缀和数组
vector<int> build_prefix_sum(vector<int>& arr) {
    int n = arr.size();
    vector<int> prefix(n + 1, 0);
    
    for (int i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] + arr[i];
    }
    
    return prefix;
}

// 查询区间和 [L, R]
int range_sum(vector<int>& prefix, int L, int R) {
    return prefix[R + 1] - prefix[L];
}

// 示例
vector<int> arr = {1, 2, 3, 4, 5};
vector<int> prefix = build_prefix_sum(arr);
// prefix = [0, 1, 3, 6, 10, 15]
cout << range_sum(prefix, 1, 3);  // 2+3+4 = 9

// 时间复杂度：build O(n), query O(1)
// 空间复杂度：O(n)
```

**2. 二维前缀和**
```cpp
// 构建二维前缀和（矩阵区域和）
vector<vector<int>> build_2d_prefix(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    vector<vector<int>> prefix(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] 
                          - prefix[i - 1][j - 1] + matrix[i - 1][j - 1];
        }
    }
    
    return prefix;
}

// 查询子矩阵和 (r1, c1) 到 (r2, c2)
int submatrix_sum(vector<vector<int>>& prefix, int r1, int c1, int r2, int c2) {
    return prefix[r2 + 1][c2 + 1] 
         - prefix[r1][c2 + 1] 
         - prefix[r2 + 1][c1] 
         + prefix[r1][c1];
}

// 示例
vector<vector<int>> matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
auto prefix_2d = build_2d_prefix(matrix);
cout << submatrix_sum(prefix_2d, 1, 1, 2, 2);  // 5+6+8+9 = 28

// 时间复杂度：build O(mn), query O(1)
```

**3. 一维差分**
```cpp
// 构建差分数组
vector<int> build_difference(vector<int>& arr) {
    int n = arr.size();
    vector<int> diff(n + 1, 0);
    
    diff[0] = arr[0];
    for (int i = 1; i < n; i++) {
        diff[i] = arr[i] - arr[i - 1];
    }
    
    return diff;
}

// 区间 [L, R] 增加 val
void range_add(vector<int>& diff, int L, int R, int val) {
    diff[L] += val;
    diff[R + 1] -= val;
}

// 还原数组
vector<int> restore_array(vector<int>& diff) {
    int n = diff.size() - 1;
    vector<int> arr(n);
    arr[0] = diff[0];
    
    for (int i = 1; i < n; i++) {
        arr[i] = arr[i - 1] + diff[i];
    }
    
    return arr;
}

// 示例
vector<int> arr = {1, 2, 3, 4, 5};
vector<int> diff = build_difference(arr);
range_add(diff, 1, 3, 10);  // [1,3]区间+10
auto result = restore_array(diff);
// result = {1, 12, 13, 14, 5}

// 时间复杂度：build O(n), update O(1), restore O(n)
```

**4. 二维差分**
```cpp
// 子矩阵 (r1, c1) 到 (r2, c2) 增加 val
void range_add_2d(vector<vector<int>>& diff, int r1, int c1, int r2, int c2, int val) {
    diff[r1][c1] += val;
    diff[r1][c2 + 1] -= val;
    diff[r2 + 1][c1] -= val;
    diff[r2 + 1][c2 + 1] += val;
}

// 还原二维数组
vector<vector<int>> restore_matrix(vector<vector<int>>& diff) {
    int m = diff.size() - 1, n = diff[0].size() - 1;
    vector<vector<int>> matrix(m, vector<int>(n));
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 && j == 0) {
                matrix[i][j] = diff[i][j];
            } else if (i == 0) {
                matrix[i][j] = matrix[i][j - 1] + diff[i][j];
            } else if (j == 0) {
                matrix[i][j] = matrix[i - 1][j] + diff[i][j];
            } else {
                matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1] 
                              - matrix[i - 1][j - 1] + diff[i][j];
            }
        }
    }
    
    return matrix;
}

// 示例
vector<vector<int>> diff(11, vector<int>(11, 0));
range_add_2d(diff, 1, 1, 3, 3, 1);
range_add_2d(diff, 2, 2, 4, 4, 2);
auto matrix = restore_matrix(diff);
```

**5. 哈希前缀和**
```cpp
// 求和为k的连续子数组个数
int subarraySum(vector<int>& nums, int k) {
    unordered_map<int, int> prefix_count;
    prefix_count[0] = 1;  // 前缀和为0出现1次
    
    int prefix_sum = 0, count = 0;
    for (int num : nums) {
        prefix_sum += num;
        
        // 查找 prefix_sum - k
        if (prefix_count.count(prefix_sum - k)) {
            count += prefix_count[prefix_sum - k];
        }
        
        prefix_count[prefix_sum]++;
    }
    
    return count;
}

// LeetCode 560
// 时间复杂度：O(n)
```

**6. 异或前缀和**
```cpp
// 异或性质：a ^ a = 0, a ^ 0 = a
// 区间异或值 = prefix[R] ^ prefix[L-1]
vector<int> build_xor_prefix(vector<int>& arr) {
    int n = arr.size();
    vector<int> prefix(n + 1, 0);
    
    for (int i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] ^ arr[i];
    }
    
    return prefix;
}

int range_xor(vector<int>& prefix, int L, int R) {
    return prefix[R + 1] ^ prefix[L];
}

// 应用：LeetCode 1310 - 子数组异或查询
```

**7. 前缀积（取模）**
```cpp
// 用于乘法运算（注意溢出和除法）
vector<long long> build_product_prefix(vector<int>& arr, int MOD) {
    int n = arr.size();
    vector<long long> prefix(n + 1, 1);
    
    for (int i = 0; i < n; i++) {
        prefix[i + 1] = (prefix[i] * arr[i]) % MOD;
    }
    
    return prefix;
}

// 注意：查询区间积需要逆元
```

**8. 树上前缀和**
```cpp
// 树上路径和查询
class TreePrefixSum {
    vector<vector<int>> graph;
    vector<int> depth, prefix_sum;
    
    void dfs(int u, int parent, int sum) {
        prefix_sum[u] = sum;
        
        for (int v : graph[u]) {
            if (v != parent) {
                dfs(v, u, sum + weight[v]);
            }
        }
    }
    
public:
    // 根到u的路径和
    int path_sum(int u) {
        return prefix_sum[u];
    }
    
    // u到v的路径和（需要LCA）
    int path_sum(int u, int v, int lca) {
        return prefix_sum[u] + prefix_sum[v] - 2 * prefix_sum[lca];
    }
};
```

**9. 应用：LeetCode题目**
```cpp
// LeetCode 303：区域和检索 - 数组不可变
class NumArray {
    vector<int> prefix;
    
public:
    NumArray(vector<int>& nums) {
        prefix.resize(nums.size() + 1, 0);
        for (int i = 0; i < nums.size(); i++) {
            prefix[i + 1] = prefix[i] + nums[i];
        }
    }
    
    int sumRange(int left, int right) {
        return prefix[right + 1] - prefix[left];
    }
};

// LeetCode 1094：拼车（差分）
bool carPooling(vector<vector<int>>& trips, int capacity) {
    vector<int> diff(1001, 0);
    
    for (auto& trip : trips) {
        diff[trip[1]] += trip[0];
        diff[trip[2]] -= trip[0];
    }
    
    int passengers = 0;
    for (int i = 0; i < 1001; i++) {
        passengers += diff[i];
        if (passengers > capacity) return false;
    }
    
    return true;
}
```

## 应用场景
- 区间查询：快速求区间和、积、异或
- 区间修改：批量更新数据
- 子数组问题：和为k的子数组
- 矩阵查询：子矩阵和
- 航班预订：座位统计
- 日程安排：资源占用

## 注意事项
- 前缀和下标通常从1开始（避免边界处理）
- 差分适用于多次区间修改+一次查询
- 二维前缀和容斥原理（加减两次）
- 哈希前缀和用于求和为k的子数组
- 异或前缀和用于区间异或查询
- 前缀积需要处理除法和取模

## 关联知识
与 [[树状数组]]、[[线段树]]、[[滑动窗口]] 相关。

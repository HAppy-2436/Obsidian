# 字符串哈希

## 定义
字符串哈希将字符串映射为整数（哈希值），支持 O(1) 比较两个子串是否相等。常用多项式滚动哈希（Polynomial Rolling Hash），以 base 和 mod 为参数，通过前缀哈希实现快速子串比较。

## 核心内容
**1. 单哈希（基础实现）**
```cpp
struct StringHash {
    static const int BASE = 131;
    static const long long MOD = 1e9 + 7;
    
    int n;
    vector<long long> hash_val, power;
    
    StringHash(const string& s): n(s.size()), hash_val(n + 1), power(n + 1) {
        power[0] = 1;
        for (int i = 0; i < n; ++i) {
            hash_val[i + 1] = (hash_val[i] * BASE + s[i]) % MOD;
            power[i + 1] = (power[i] * BASE) % MOD;
        }
    }
    
    // 获取子串 [l, r) 的哈希值
    long long get_hash(int l, int r) {
        long long res = (hash_val[r] - hash_val[l] * power[r - l]) % MOD;
        return (res + MOD) % MOD;
    }
    
    // 判断两个子串是否相等
    bool equal(int l1, int r1, int l2, int r2) {
        return get_hash(l1, r1) == get_hash(l2, r2);
    }
};

// 时间复杂度：预处理 O(n)，查询 O(1)
```

**2. 双哈希（降低冲突）**
```cpp
struct DoubleHash {
    static const int BASE1 = 131, BASE2 = 13331;
    static const long long MOD1 = 1e9 + 7, MOD2 = 1e9 + 9;
    
    int n;
    vector<long long> hash1, hash2, pow1, pow2;
    
    DoubleHash(const string& s): n(s.size()), 
        hash1(n + 1), hash2(n + 1), pow1(n + 1), pow2(n + 1) {
        pow1[0] = pow2[0] = 1;
        for (int i = 0; i < n; ++i) {
            hash1[i + 1] = (hash1[i] * BASE1 + s[i]) % MOD1;
            hash2[i + 1] = (hash2[i] * BASE2 + s[i]) % MOD2;
            pow1[i + 1] = (pow1[i] * BASE1) % MOD1;
            pow2[i + 1] = (pow2[i] * BASE2) % MOD2;
        }
    }
    
    pair<long long, long long> get_hash(int l, int r) {
        long long h1 = (hash1[r] - hash1[l] * pow1[r - l]) % MOD1;
        long long h2 = (hash2[r] - hash2[l] * pow2[r - l]) % MOD2;
        return {(h1 + MOD1) % MOD1, (h2 + MOD2) % MOD2};
    }
    
    bool equal(int l1, int r1, int l2, int r2) {
        return get_hash(l1, r1) == get_hash(l2, r2);
    }
};
```

**3. Rabin-Karp 算法（字符串匹配）**
```cpp
// 在文本 text 中查找模式 pattern 的所有出现位置
vector<int> rabin_karp(const string& text, const string& pattern) {
    int n = text.size(), m = pattern.size();
    if (m > n) return {};
    
    const int BASE = 131;
    const long long MOD = 1e9 + 7;
    
    // 计算 pattern 的哈希值
    long long pattern_hash = 0, power = 1;
    for (int i = 0; i < m; ++i) {
        pattern_hash = (pattern_hash * BASE + pattern[i]) % MOD;
        if (i < m - 1) power = (power * BASE) % MOD;
    }
    
    // 滚动哈希匹配
    vector<int> matches;
    long long text_hash = 0;
    for (int i = 0; i < n; ++i) {
        text_hash = (text_hash * BASE + text[i]) % MOD;
        
        if (i >= m - 1) {
            if (text_hash == pattern_hash) {
                // 哈希值相同，再比较确认（避免误判）
                if (text.substr(i - m + 1, m) == pattern) {
                    matches.push_back(i - m + 1);
                }
            }
            
            // 移除最左字符
            if (i < n - 1) {
                text_hash = (text_hash - text[i - m + 1] * power) % MOD;
                text_hash = (text_hash + MOD) % MOD;
            }
        }
    }
    
    return matches;
}
```

**4. 最长公共子串（哈希+二分）**
```cpp
// 求两个字符串的最长公共子串长度
int longest_common_substring(const string& s1, const string& s2) {
    StringHash h1(s1), h2(s2);
    int n1 = s1.size(), n2 = s2.size();
    
    auto check = [&](int len) {
        unordered_set<long long> set1;
        for (int i = 0; i + len <= n1; ++i) {
            set1.insert(h1.get_hash(i, i + len));
        }
        for (int i = 0; i + len <= n2; ++i) {
            if (set1.count(h2.get_hash(i, i + len))) return true;
        }
        return false;
    };
    
    int left = 0, right = min(n1, n2) + 1;
    while (left < right) {
        int mid = (left + right) / 2;
        if (check(mid)) left = mid + 1;
        else right = mid;
    }
    
    return left - 1;
}

// 时间复杂度：O((n1 + n2) log min(n1, n2))
```

**5. 回文子串判断**
```cpp
// 判断 s[l..r] 是否为回文
bool is_palindrome_hash(const string& s, int l, int r) {
    string rev = s;
    reverse(rev.begin(), rev.end());
    
    StringHash h1(s), h2(rev);
    int n = s.size();
    
    return h1.get_hash(l, r + 1) == h2.get_hash(n - r - 1, n - l);
}
```

**6. 最小循环节**
```cpp
// 找字符串的最小循环节长度
int min_period(const string& s) {
    int n = s.size();
    StringHash h(s);
    
    for (int len = 1; len <= n; ++len) {
        if (n % len != 0) continue;
        
        bool is_period = true;
        long long first_hash = h.get_hash(0, len);
        
        for (int i = len; i < n; i += len) {
            if (h.get_hash(i, i + len) != first_hash) {
                is_period = false;
                break;
            }
        }
        
        if (is_period) return len;
    }
    
    return n;
}
```

**7. 常用参数选择**
```cpp
// 推荐参数组合（降低冲突）
// BASE: 131, 13331, 233
// MOD: 1e9+7, 1e9+9, 998244353
// 或使用 unsigned long long 自然溢出（2^64）

// 自然溢出版本
struct ULLHash {
    static const int BASE = 131;
    int n;
    vector<unsigned long long> hash_val, power;
    
    ULLHash(const string& s): n(s.size()), hash_val(n + 1), power(n + 1) {
        power[0] = 1;
        for (int i = 0; i < n; ++i) {
            hash_val[i + 1] = hash_val[i] * BASE + s[i];
            power[i + 1] = power[i] * BASE;
        }
    }
    
    unsigned long long get_hash(int l, int r) {
        return hash_val[r] - hash_val[l] * power[r - l];
    }
};
```

## 应用场景
- 字符串匹配（Rabin-Karp）
- 最长公共子串/子序列
- 回文串判断与查找
- 字符串去重与比较
- 子串频次统计
- 滚动哈希优化

## 注意事项
- 单哈希有冲突风险，双哈希更可靠
- 选择合适的 BASE 和 MOD（互质、足够大）
- 注意取模运算的负数处理
- Rabin-Karp 哈希值相同需再次确认
- unsigned long long 自然溢出简化代码
- 预处理前缀哈希和幂次，查询 O(1)
- 比较子串相等用哈希值，不要直接比较字符串

## 关联知识
与 [[KMP算法]]、[[字符串]]、[[哈希表]]、[[滚动哈希]] 相关。

# 单调栈

## 定义
单调栈是栈内元素保持单调性（递增或递减）的数据结构，用于O(n)解决"下一个更大/更小元素"、"区间最值"等问题，核心思想是维护有用信息、及时淘汰无用元素。

## 核心内容
**1. 单调递减栈（找下一个更大元素）**
```cpp
// 每个元素右侧第一个比它大的元素
vector<int> nextGreaterElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1);
    stack<int> st;  // 存储下标
    
    for (int i = 0; i < n; i++) {
        // 当前元素更大时，弹出栈中较小元素
        while (!st.empty() && nums[i] > nums[st.top()]) {
            result[st.top()] = nums[i];
            st.pop();
        }
        st.push(i);
    }
    
    return result;
}

// 示例：nums = [2, 1, 2, 4, 3]
// result = [4, 2, 4, -1, -1]

// 时间复杂度：O(n)，每个元素入栈出栈各一次
// 空间复杂度：O(n)
```

**2. 单调递增栈（找下一个更小元素）**
```cpp
// 每个元素右侧第一个比它小的元素
vector<int> nextSmallerElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1);
    stack<int> st;
    
    for (int i = 0; i < n; i++) {
        // 当前元素更小时，弹出栈中较大元素
        while (!st.empty() && nums[i] < nums[st.top()]) {
            result[st.top()] = nums[i];
            st.pop();
        }
        st.push(i);
    }
    
    return result;
}

// 示例：nums = [4, 3, 2, 1, 5]
// result = [3, 2, 1, -1, -1]
```

**3. 前一个更大元素**
```cpp
// 每个元素左侧第一个比它大的元素
vector<int> prevGreaterElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1);
    stack<int> st;
    
    for (int i = 0; i < n; i++) {
        // 维护单调递减栈
        while (!st.empty() && nums[st.top()] <= nums[i]) {
            st.pop();
        }
        
        if (!st.empty()) {
            result[i] = nums[st.top()];
        }
        
        st.push(i);
    }
    
    return result;
}

// 示例：nums = [2, 1, 2, 4, 3]
// result = [-1, 2, -1, -1, 4]
```

**4. 柱状图最大矩形**
```cpp
// LeetCode 84：单调栈经典应用
int largestRectangleArea(vector<int>& heights) {
    int n = heights.size();
    stack<int> st;
    int max_area = 0;
    
    for (int i = 0; i < n; i++) {
        // 当前柱子更矮时，计算以栈顶为高的矩形
        while (!st.empty() && heights[i] < heights[st.top()]) {
            int h = heights[st.top()];
            st.pop();
            
            // 宽度：左边界到右边界
            int width = st.empty() ? i : (i - st.top() - 1);
            max_area = max(max_area, h * width);
        }
        st.push(i);
    }
    
    // 处理剩余元素
    while (!st.empty()) {
        int h = heights[st.top()];
        st.pop();
        int width = st.empty() ? n : (n - st.top() - 1);
        max_area = max(max_area, h * width);
    }
    
    return max_area;
}

// 示例：heights = [2, 1, 5, 6, 2, 3]
// 最大矩形：高5，宽2，面积10

// 时间复杂度：O(n)
```

**5. 接雨水**
```cpp
// LeetCode 42：另一种单调栈应用
int trap(vector<int>& height) {
    int n = height.size();
    stack<int> st;
    int water = 0;
    
    for (int i = 0; i < n; i++) {
        // 当前柱子更高时，计算积水
        while (!st.empty() && height[i] > height[st.top()]) {
            int bottom = st.top();
            st.pop();
            
            if (st.empty()) break;
            
            int left = st.top();
            int h = min(height[left], height[i]) - height[bottom];
            int w = i - left - 1;
            water += h * w;
        }
        st.push(i);
    }
    
    return water;
}

// 示例：height = [0,1,0,2,1,0,1,3,2,1,2,1]
// 接雨水总量：6

// 时间复杂度：O(n)
```

**6. 每日温度**
```cpp
// LeetCode 739：等待升温的天数
vector<int> dailyTemperatures(vector<int>& temperatures) {
    int n = temperatures.size();
    vector<int> result(n, 0);
    stack<int> st;
    
    for (int i = 0; i < n; i++) {
        while (!st.empty() && temperatures[i] > temperatures[st.top()]) {
            int prev = st.top();
            st.pop();
            result[prev] = i - prev;
        }
        st.push(i);
    }
    
    return result;
}

// 示例：temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
// result = [1, 1, 4, 2, 1, 1, 0, 0]
```

**7. 子数组最小值之和**
```cpp
// LeetCode 907：每个元素作为最小值的贡献
int sumSubarrayMins(vector<int>& arr) {
    int n = arr.size();
    const int MOD = 1e9 + 7;
    
    // left[i]：左侧第一个小于arr[i]的位置
    // right[i]：右侧第一个小于等于arr[i]的位置
    vector<int> left(n), right(n);
    stack<int> st;
    
    // 计算left
    for (int i = 0; i < n; i++) {
        while (!st.empty() && arr[st.top()] > arr[i]) {
            st.pop();
        }
        left[i] = st.empty() ? -1 : st.top();
        st.push(i);
    }
    
    // 清空栈
    while (!st.empty()) st.pop();
    
    // 计算right
    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && arr[st.top()] >= arr[i]) {
            st.pop();
        }
        right[i] = st.empty() ? n : st.top();
        st.push(i);
    }
    
    // 计算贡献
    long long result = 0;
    for (int i = 0; i < n; i++) {
        long long count = (long long)(i - left[i]) * (right[i] - i);
        result = (result + arr[i] * count) % MOD;
    }
    
    return result;
}

// 时间复杂度：O(n)
```

**8. 去除重复字母**
```cpp
// LeetCode 316：字典序最小的不含重复字母的字符串
string removeDuplicateLetters(string s) {
    vector<int> count(26, 0);
    vector<bool> in_stack(26, false);
    
    // 统计每个字符出现次数
    for (char c : s) {
        count[c - 'a']++;
    }
    
    string result;
    for (char c : s) {
        count[c - 'a']--;
        
        if (in_stack[c - 'a']) continue;
        
        // 如果栈顶字符更大且后面还会出现，弹出
        while (!result.empty() && result.back() > c && count[result.back() - 'a'] > 0) {
            in_stack[result.back() - 'a'] = false;
            result.pop_back();
        }
        
        result.push_back(c);
        in_stack[c - 'a'] = true;
    }
    
    return result;
}

// 示例："bcabc" -> "abc"
```

**9. 滑动窗口最大值（单调队列）**
```cpp
// 注：这里用单调栈的思想，实际是单调队列
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;  // 存储下标，维护单调递减
    vector<int> result;
    
    for (int i = 0; i < nums.size(); i++) {
        // 移除窗口外元素
        if (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        
        // 维护单调性
        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        // 窗口形成后记录最大值
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    
    return result;
}
```

**10. 单调栈模板总结**
```cpp
// 通用模板
vector<int> monotonic_stack_template(vector<int>& arr, bool increasing) {
    int n = arr.size();
    vector<int> result(n, -1);
    stack<int> st;
    
    for (int i = 0; i < n; i++) {
        while (!st.empty() && 
               (increasing ? arr[i] < arr[st.top()] : arr[i] > arr[st.top()])) {
            result[st.top()] = arr[i];
            st.pop();
        }
        st.push(i);
    }
    
    return result;
}

// increasing=false: 单调递减栈，找下一个更大
// increasing=true: 单调递增栈，找下一个更小
```

## 应用场景
- 下一个更大/更小元素：股票价格分析
- 柱状图问题：最大矩形面积
- 接雨水：地形积水计算
- 温度问题：天气预测
- 子数组最值：区间统计
- 字典序问题：字符串去重

## 注意事项
- 栈中存储下标而非值（方便计算宽度）
- 单调递减栈找"更大"，单调递增栈找"更小"
- 循环数组需要遍历2n次
- 处理完主循环后检查栈中剩余元素
- 维护单调性时注意等号（严格/非严格）
- 时间复杂度O(n)因为每个元素入栈出栈各一次

## 关联知识
与 [[单调队列]]、[[栈]]、[[滑动窗口]] 相关。

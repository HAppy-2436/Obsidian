# 博弈论

## 定义
博弈论研究双人零和游戏的必胜必败态，常用 Nim 游戏、SG 函数（Sprague-Grundy）判定先手必胜或必败。核心思想是将游戏状态分为 P-position（必败态）和 N-position（必胜态）。

## 核心内容
**1. Nim 游戏（异或和判定）**
```cpp
// n 堆石子，每次可从任意一堆取若干个，取光者胜
// 先手必胜当且仅当所有堆的异或和不为0
bool nim_win(vector<int>& piles) {
    int xor_sum = 0;
    for (int x : piles) xor_sum ^= x;
    return xor_sum != 0;
}

// 示例：piles = {3, 4, 5} -> xor = 3^4^5 = 2，先手必胜
// piles = {3, 3, 6} -> xor = 0，先手必败
```

**2. SG 函数（Sprague-Grundy）**
```cpp
// SG(x) = mex{SG(y) | y是x的后继状态}
// mex：最小不出现的非负整数
// SG(终态) = 0
// 多个独立游戏的 SG 值 = 各游戏 SG 值的异或和

int mex(set<int>& s) {
    int res = 0;
    while (s.count(res)) res++;
    return res;
}

// 示例：取石子游戏，每次可取 1, 2, 3 个
unordered_map<int, int> sg_memo;
int sg(int n) {
    if (n == 0) return 0;
    if (sg_memo.count(n)) return sg_memo[n];
    
    set<int> s;
    for (int take : {1, 2, 3}) {
        if (n >= take) s.insert(sg(n - take));
    }
    return sg_memo[n] = mex(s);
}

// 判定先手必胜：sg(n) != 0
bool can_win(int n) {
    return sg(n) != 0;
}
```

**3. 巴什博弈（Bash Game）**
```cpp
// n 个石子，每次可取 1~m 个，取光者胜
// 先手必败当且仅当 n % (m+1) == 0
bool bash_win(int n, int m) {
    return n % (m + 1) != 0;
}

// 最优策略：取 n % (m+1) 个，使对手面对 (m+1) 的倍数
int bash_strategy(int n, int m) {
    int r = n % (m + 1);
    return r == 0 ? 1 : r; // 必败时随便取
}
```

**4. 威佐夫博弈（Wythoff Game）**
```cpp
// 两堆石子，每次可从一堆取任意个或两堆取相同个数
// 必败态满足：min(a,b) = floor(|a-b| * φ)，φ=(1+√5)/2
bool wythoff_win(int a, int b) {
    if (a > b) swap(a, b);
    int diff = b - a;
    int k = (int)(diff * 0.618034); // φ-1 ≈ 0.618
    return a != k;
}
```

**5. 阶梯博弈**
```cpp
// n 个阶梯，每个阶梯有 a[i] 个石子，可从任意阶梯移石子到下一阶
// 等价于奇数阶梯的 Nim 游戏
bool staircase_win(vector<int>& stairs) {
    int xor_sum = 0;
    for (int i = 0; i < stairs.size(); i++) {
        if (i % 2 == 1) xor_sum ^= stairs[i]; // 只考虑奇数阶
    }
    return xor_sum != 0;
}
```

**6. 翻硬币游戏**
```cpp
// n 个硬币，正面朝上，每次翻转连续若干个，全部朝下为胜
// SG 值：二进制表示中1的个数
int coin_sg(int n) {
    return __builtin_popcount(n);
}

bool coin_win(vector<int>& positions) {
    int xor_sum = 0;
    for (int pos : positions) xor_sum ^= coin_sg(pos);
    return xor_sum != 0;
}
```

**7. 多游戏组合（SG 定理）**
```cpp
// 多个独立游戏，总 SG 值 = 各游戏 SG 值异或和
// 先手必胜当且仅当总 SG != 0
bool multi_game_win(vector<int>& sg_values) {
    int total_sg = 0;
    for (int sg : sg_values) total_sg ^= sg;
    return total_sg != 0;
}
```

**8. P-position 和 N-position**
```
P-position（必败态）：
- 终态是 P-position
- 所有后继都是 N-position

N-position（必胜态）：
- 至少有一个后继是 P-position
```

## 应用场景
- 石子游戏、取数游戏
- 组合游戏理论（CGT）
- 棋类游戏的胜负判定
- 博弈 DP 问题
- 公平组合游戏（ICG）

## 注意事项
- Nim 游戏核心是异或和
- SG 函数需要记忆化搜索避免超时
- 巴什博弈关键是 (m+1) 的倍数
- 威佐夫博弈需要黄金分割比
- 多游戏组合用 SG 定理
- 终态 SG 值为 0（P-position）
- 先手必胜 ⇔ SG != 0

## 关联知识
与 [[动态规划]]、[[数学]]、[[组合数学]]、[[记忆化搜索]] 相关。

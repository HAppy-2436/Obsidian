# 最短路算法

## 定义
最短路算法求解图中两点之间的最短路径。主要包括Dijkstra算法（非负权）、Bellman-Ford算法（可有负权）、Floyd算法（全源最短路）、SPFA算法（Bellman-Ford优化）。

## 核心内容
**1. Dijkstra算法（单源最短路，非负权）**
```cpp
#include <queue>
#include <vector>
using namespace std;

const int INF = 0x3f3f3f3f;

// 邻接表
vector<pair<int, int>> graph[MAXN];  // {to, weight}
int dist[MAXN];
bool vis[MAXN];

void dijkstra(int start, int n) {
    fill(dist, dist + n, INF);
    fill(vis, vis + n, false);
    dist[start] = 0;
    
    // 优先队列：{距离, 节点}
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    pq.push({0, start});
    
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        
        if (vis[u]) continue;
        vis[u] = true;
        
        for (auto [v, w] : graph[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
}

// 时间复杂度：O((V+E) log V)
```

**2. Bellman-Ford算法（单源最短路，可负权）**
```cpp
struct Edge {
    int from, to, weight;
};

vector<Edge> edges;
int dist[MAXN];

bool bellman_ford(int start, int n) {
    fill(dist, dist + n, INF);
    dist[start] = 0;
    
    // 松弛 n-1 次
    for (int i = 0; i < n - 1; i++) {
        for (auto& e : edges) {
            if (dist[e.from] != INF && dist[e.from] + e.weight < dist[e.to]) {
                dist[e.to] = dist[e.from] + e.weight;
            }
        }
    }
    
    // 检测负环
    for (auto& e : edges) {
        if (dist[e.from] != INF && dist[e.from] + e.weight < dist[e.to]) {
            return false;  // 有负环
        }
    }
    return true;
}

// 时间复杂度：O(VE)
```

**3. SPFA算法（Bellman-Ford队列优化）**
```cpp
bool spfa(int start, int n) {
    fill(dist, dist + n, INF);
    vector<int> cnt(n, 0);  // 入队次数
    vector<bool> inQueue(n, false);
    
    queue<int> q;
    q.push(start);
    dist[start] = 0;
    inQueue[start] = true;
    cnt[start]++;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inQueue[u] = false;
        
        for (auto [v, w] : graph[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                if (!inQueue[v]) {
                    q.push(v);
                    inQueue[v] = true;
                    cnt[v]++;
                    if (cnt[v] >= n) return false;  // 负环
                }
            }
        }
    }
    return true;
}

// 平均：O(kE)，最坏：O(VE)
```

**4. Floyd算法（全源最短路）**
```cpp
int dist[MAXN][MAXN];

void floyd(int n) {
    // 初始化
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) dist[i][j] = 0;
            else dist[i][j] = INF;
        }
    }
    
    // 读入边
    // dist[u][v] = weight;
    
    // 枚举中间节点
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}

// 时间复杂度：O(V³)
```

**5. 路径记录**
```cpp
int parent[MAXN];

// Dijkstra中记录前驱
void dijkstra_with_path(int start, int n) {
    // ... 初始化
    fill(parent, parent + n, -1);
    
    while (!pq.empty()) {
        // ...
        for (auto [v, w] : graph[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                parent[v] = u;  // 记录前驱
                pq.push({dist[v], v});
            }
        }
    }
}

// 输出路径
void print_path(int end) {
    if (parent[end] == -1) {
        cout << end;
        return;
    }
    print_path(parent[end]);
    cout << " -> " << end;
}
```

**6. DAG最短路（拓扑排序+DP）**
```cpp
// 有向无环图，可有负权
int topo_shortest_path(int start, int n) {
    vector<int> in_degree(n, 0);
    vector<int> dist(n, INF);
    dist[start] = 0;
    
    // 计算入度
    for (int u = 0; u < n; u++) {
        for (auto [v, w] : graph[u]) {
            in_degree[v]++;
        }
    }
    
    // 拓扑排序
    queue<int> q;
    for (int i = 0; i < n; i++) {
        if (in_degree[i] == 0) q.push(i);
    }
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : graph[u]) {
            dist[v] = min(dist[v], dist[u] + w);
            if (--in_degree[v] == 0) {
                q.push(v);
            }
        }
    }
}

// 时间复杂度：O(V+E)
```

**7. 算法对比**
| 算法 | 适用场景 | 时间复杂度 | 空间复杂度 |
|------|----------|------------|------------|
| Dijkstra | 非负权，单源 | O(E log V) | O(V+E) |
| Bellman-Ford | 可负权，单源 | O(VE) | O(V+E) |
| SPFA | 可负权，单源 | O(kE) | O(V+E) |
| Floyd | 全源最短路 | O(V³) | O(V²) |
| 拓扑+DP | DAG | O(V+E) | O(V+E) |

**8. 差分约束系统**
```cpp
// 形如 xi - xj <= ck 的不等式组
// 转化为最短路问题：j -> i 权值 ck
// 求解即判断是否有负环

bool solve_constraints(int n) {
    // 添加超级源点连接所有点
    for (int i = 0; i < n; i++) {
        graph[n].push_back({i, 0});
    }
    return spfa(n, n + 1);
}
```

## 应用场景
- 地图导航：最短路径规划
- 网络路由：数据包路由
- 社交网络：六度分离理论
- 游戏AI：寻路算法
- 差分约束：不等式组求解
- 图的直径：最远两点距离

## 注意事项
- Dijkstra不能处理负权边
- Bellman-Ford能检测负环
- SPFA最坏情况退化为Bellman-Ford
- Floyd适合稠密图和小规模图
- 注意INF溢出问题：`INF + w`
- 路径记录需要额外数组

## 关联知识
与 [[拓扑排序]]、[[最小生成树]]、[[动态规划]] 相关。

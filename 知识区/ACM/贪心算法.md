# 贪心算法

## 定义
贪心算法每一步都选择当前状态下的局部最优解，期望通过局部最优达到全局最优。使用前需证明贪心选择性质和最优子结构，否则可能得到错误结果。

## 核心内容
**1. 贪心策略证明**
- **贪心选择性质**：局部最优选择能导致全局最优
- **最优子结构**：原问题的最优解包含子问题的最优解
- **证明方法**：数学归纳、交换论证、反证法

**2. 区间调度问题**
```cpp
// 选择最多不重叠区间
struct Interval {
    int start, end;
    bool operator<(const Interval& other) const {
        return end < other.end;  // 按结束时间排序
    }
};

int maxIntervals(vector<Interval>& intervals) {
    sort(intervals.begin(), intervals.end());
    int count = 0, lastEnd = INT_MIN;
    for (auto& iv : intervals) {
        if (iv.start >= lastEnd) {
            count++;
            lastEnd = iv.end;
        }
    }
    return count;
}
```

**3. 霍夫曼编码（最优前缀编码）**
```cpp
struct Node {
    int freq;
    Node *left, *right;
    bool operator>(const Node& other) const {
        return freq > other.freq;
    }
};

Node* huffman(vector<int>& freqs) {
    priority_queue<Node*, vector<Node*>, greater<Node*>> pq;
    
    // 初始化叶子节点
    for (int f : freqs) {
        pq.push(new Node{f, nullptr, nullptr});
    }
    
    // 合并最小的两个节点
    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();
        Node* parent = new Node{left->freq + right->freq, left, right};
        pq.push(parent);
    }
    
    return pq.top();
}
```

**4. 活动选择（会议室安排）**
```cpp
// 贪心策略：选择最早结束的活动
int activitySelection(int start[], int end[], int n) {
    // 按结束时间排序
    vector<pair<int, int>> activities;
    for (int i = 0; i < n; i++) {
        activities.push_back({end[i], start[i]});
    }
    sort(activities.begin(), activities.end());
    
    int count = 1;
    int lastEnd = activities[0].first;
    for (int i = 1; i < n; i++) {
        if (activities[i].second >= lastEnd) {
            count++;
            lastEnd = activities[i].first;
        }
    }
    return count;
}
```

**5. 分糖果问题**
```cpp
// 每个孩子至少1个糖果，评分高的比邻居多
int candy(vector<int>& ratings) {
    int n = ratings.size();
    vector<int> candies(n, 1);
    
    // 从左到右：右边评分高则多给
    for (int i = 1; i < n; i++) {
        if (ratings[i] > ratings[i-1]) {
            candies[i] = candies[i-1] + 1;
        }
    }
    
    // 从右到左：左边评分高则多给
    for (int i = n-2; i >= 0; i--) {
        if (ratings[i] > ratings[i+1]) {
            candies[i] = max(candies[i], candies[i+1] + 1);
        }
    }
    
    return accumulate(candies.begin(), candies.end(), 0);
}
```

**6. 背包取物（分数背包）**
```cpp
struct Item {
    int value, weight;
    double ratio;
    Item(int v, int w) : value(v), weight(w), ratio((double)v/w) {}
    bool operator<(const Item& other) const {
        return ratio > other.ratio;  // 性价比降序
    }
};

double fractionalKnapsack(int W, vector<Item>& items) {
    sort(items.begin(), items.end());
    double total = 0;
    for (auto& item : items) {
        if (W >= item.weight) {
            total += item.value;
            W -= item.weight;
        } else {
            total += item.ratio * W;
            break;
        }
    }
    return total;
}
```

**7. 跳跃游戏**
```cpp
// 判断能否到达最后一个位置
bool canJump(vector<int>& nums) {
    int maxReach = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (i > maxReach) return false;  // 当前位置不可达
        maxReach = max(maxReach, i + nums[i]);
        if (maxReach >= nums.size() - 1) return true;
    }
    return true;
}

// 最少跳跃次数
int jump(vector<int>& nums) {
    int jumps = 0, curEnd = 0, curFarthest = 0;
    for (int i = 0; i < nums.size() - 1; i++) {
        curFarthest = max(curFarthest, i + nums[i]);
        if (i == curEnd) {
            jumps++;
            curEnd = curFarthest;
        }
    }
    return jumps;
}
```

**8. 加油站问题**
```cpp
// 找起始加油站使得能环绕一圈
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    int totalGas = 0, currentGas = 0, start = 0;
    for (int i = 0; i < gas.size(); i++) {
        totalGas += gas[i] - cost[i];
        currentGas += gas[i] - cost[i];
        if (currentGas < 0) {
            start = i + 1;  // 从下一个开始
            currentGas = 0;
        }
    }
    return totalGas >= 0 ? start : -1;
}
```

**9. 贪心 vs 动态规划**
| 特性 | 贪心算法 | 动态规划 |
|------|----------|----------|
| 策略 | 局部最优 | 全局最优 |
| 子问题 | 不重叠 | 重叠 |
| 适用性 | 需证明贪心性质 | 适用范围广 |
| 时间复杂度 | 通常O(n)或O(n log n) | 通常O(n²)或更高 |
| 例子 | 活动选择 | 01背包 |

## 应用场景
- 区间调度：会议室安排、活动选择
- 哈夫曼编码：数据压缩
- 最小生成树：Kruskal、Prim算法
- 最短路径：Dijkstra算法
- 分数背包：可分割物品
- 任务调度：单机调度

## 注意事项
- 贪心不一定得到最优解（需证明）
- 01背包不能用贪心（需DP）
- 贪心策略不唯一，需选择正确的
- 排序是贪心的常用手段
- 局部最优≠全局最优
- 反例检验：尝试构造反例

## 关联知识
与 [[动态规划]]、[[最小生成树]]、[[最短路算法]] 相关。

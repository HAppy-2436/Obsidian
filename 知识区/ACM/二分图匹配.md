# 二分图匹配

## 定义
二分图匹配是在二分图中找最大匹配（最多边集且边不共享端点）的问题。常用匈牙利算法（O(VE)）或 Hopcroft-Karp 算法（O(E√V)）求解。König定理指出：二分图最大匹配数=最小点覆盖数。

## 核心内容
**1. 匈牙利算法（增广路法）**
```cpp
// 左部 n 个点，右部 m 个点，adj[u] 为 u 连接的右部点
struct Hungarian {
    int n, m;
    vector<vector<int>> adj;
    vector<int> match; // match[v] 为右部点 v 匹配的左部点
    vector<bool> vis;

    Hungarian(int _n, int _m): n(_n), m(_m), adj(n), match(m, -1) {}

    void add_edge(int u, int v) { adj[u].push_back(v); }

    bool dfs(int u) {
        for (int v : adj[u]) {
            if (vis[v]) continue;
            vis[v] = true;
            if (match[v] == -1 || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
        return false;
    }

    int max_matching() {
        int res = 0;
        for (int u = 0; u < n; ++u) {
            vis.assign(m, false);
            if (dfs(u)) res++;
        }
        return res;
    }
};
// 时间复杂度：O(VE)
```

**2. Hopcroft-Karp 算法（更快）**
```cpp
struct HopcroftKarp {
    int n, m;
    vector<vector<int>> adj;
    vector<int> pa, pb, dist;
    const int INF = 1e9;

    HopcroftKarp(int _n, int _m): n(_n), m(_m), adj(n), pa(n, -1), pb(m, -1), dist(n) {}

    void add_edge(int u, int v) { adj[u].push_back(v); }

    bool bfs() {
        queue<int> q;
        for (int u = 0; u < n; ++u) {
            if (pa[u] == -1) {
                dist[u] = 0;
                q.push(u);
            } else {
                dist[u] = INF;
            }
        }
        bool found = false;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int v : adj[u]) {
                int w = pb[v];
                if (w == -1) {
                    found = true;
                } else if (dist[w] == INF) {
                    dist[w] = dist[u] + 1;
                    q.push(w);
                }
            }
        }
        return found;
    }

    bool dfs(int u) {
        for (int v : adj[u]) {
            int w = pb[v];
            if (w == -1 || (dist[w] == dist[u] + 1 && dfs(w))) {
                pa[u] = v;
                pb[v] = u;
                return true;
            }
        }
        dist[u] = INF;
        return false;
    }

    int max_matching() {
        int res = 0;
        while (bfs()) {
            for (int u = 0; u < n; ++u) {
                if (pa[u] == -1 && dfs(u)) res++;
            }
        }
        return res;
    }
};
// 时间复杂度：O(E√V)
```

**3. König定理与最小点覆盖**
```cpp
// 二分图最大匹配数 = 最小点覆盖数
// 最小点覆盖：选最少点覆盖所有边
// 最大独立集 = n - 最小点覆盖
int min_vertex_cover(Hungarian& h) {
    return h.max_matching();
}
```

**4. 完美匹配判定**
```cpp
// 完美匹配：左右部点数相等且匹配数 = n
bool has_perfect_matching(int n, int m, Hungarian& h) {
    if (n != m) return false;
    return h.max_matching() == n;
}
```

## 应用场景
- 任务分配（工人-任务二分图）
- 稳定婚姻问题
- 最大独立集、最小点覆盖（二分图特性）
- 网络流建模（转化为最大流问题）
- 资源调度、课程排课

## 注意事项
- 匈牙利算法适用于稀疏图，Hopcroft-Karp 适合稠密图
- König定理仅适用于二分图
- 最大独立集 = 总点数 - 最小点覆盖
- 完美匹配要求左右部点数相等
- 注意左右部点的编号范围
- 增广路每次找到后立即更新匹配

## 关联知识
与 [[网络流]]、[[图论]]、[[最大流最小割]]、[[贪心算法]] 相关。
